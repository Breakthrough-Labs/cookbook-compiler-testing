{"language":"Solidity","sources":{"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/lib/ds-test/src/test.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/auth/Auth.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnershipTransferred(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function transferOwnership(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/auth/Owned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/auth/authorities/MultiRolesAuthority.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/auth/authorities/RolesAuthority.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/Auth.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\ncontract OutOfOrderAuthority is Authority {\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public pure override returns (bool) {\n        revert(\"OUT_OF_ORDER\");\n    }\n}\n\ncontract AuthTest is DSTestPlus {\n    MockAuthChild mockAuthChild;\n\n    function setUp() public {\n        mockAuthChild = new MockAuthChild();\n    }\n\n    function testTransferOwnershipAsOwner() public {\n        mockAuthChild.transferOwnership(address(0xBEEF));\n        assertEq(mockAuthChild.owner(), address(0xBEEF));\n    }\n\n    function testSetAuthorityAsOwner() public {\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n        assertEq(address(mockAuthChild.authority()), address(0xBEEF));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockAuthChild.updateFlag();\n    }\n\n    function testTransferOwnershipWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(this));\n    }\n\n    function testSetAuthorityWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testCallFunctionWithPermissiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testSetAuthorityAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.setAuthority(new MockAuthority(true));\n    }\n\n    function testFailTransferOwnershipAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(0xBEEF));\n    }\n\n    function testFailSetAuthorityAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionAsNonOwner() public {\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.transferOwnership(address(this));\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.setAuthority(Authority(address(0xBEEF)));\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority() public {\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(address(0));\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.transferOwnership(address(0));\n    }\n\n    function testFailCallFunctionAsOwnerWithOutOfOrderAuthority() public {\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.updateFlag();\n    }\n\n    function testTransferOwnershipAsOwner(address newOwner) public {\n        mockAuthChild.transferOwnership(newOwner);\n        assertEq(mockAuthChild.owner(), newOwner);\n    }\n\n    function testSetAuthorityAsOwner(Authority newAuthority) public {\n        mockAuthChild.setAuthority(newAuthority);\n        assertEq(address(mockAuthChild.authority()), address(newAuthority));\n    }\n\n    function testTransferOwnershipWithPermissiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testSetAuthorityWithPermissiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testCallFunctionWithPermissiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(true));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsNonOwner(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testFailSetAuthorityAsNonOwner(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionAsNonOwner(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipWithRestrictiveAuthority(address deadOwner, address newOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.transferOwnership(newOwner);\n    }\n\n    function testFailSetAuthorityWithRestrictiveAuthority(address deadOwner, Authority newAuthority) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.setAuthority(newAuthority);\n    }\n\n    function testFailCallFunctionWithRestrictiveAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new MockAuthority(false));\n        mockAuthChild.transferOwnership(deadOwner);\n        mockAuthChild.updateFlag();\n    }\n\n    function testFailTransferOwnershipAsOwnerWithOutOfOrderAuthority(address deadOwner) public {\n        if (deadOwner == address(this)) deadOwner = address(0);\n\n        mockAuthChild.setAuthority(new OutOfOrderAuthority());\n        mockAuthChild.transferOwnership(deadOwner);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/Bytes32AddressLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {Bytes32AddressLib} from \"../utils/Bytes32AddressLib.sol\";\n\ncontract Bytes32AddressLibTest is DSTestPlus {\n    function testFillLast12Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fillLast12Bytes(0xfEEDFaCEcaFeBEEFfEEDFACecaFEBeeFfeEdfAce),\n            0xfeedfacecafebeeffeedfacecafebeeffeedface000000000000000000000000\n        );\n    }\n\n    function testFromLast20Bytes() public {\n        assertEq(\n            Bytes32AddressLib.fromLast20Bytes(0xfeedfacecafebeeffeedfacecafebeeffeedfacecafebeeffeedfacecafebeef),\n            0xCAfeBeefFeedfAceCAFeBEEffEEDfaCecafEBeeF\n        );\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/CREATE3.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {WETH} from \"../tokens/WETH.sol\";\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockAuthChild} from \"./utils/mocks/MockAuthChild.sol\";\n\nimport {CREATE3} from \"../utils/CREATE3.sol\";\n\ncontract Factory {\n    function deploy(bytes32 salt) public returns (address deployed) {\n        deployed = CREATE3.deploy(\n            salt,\n            abi.encodePacked(type(MockERC20).creationCode, abi.encode(\"Mock Token\", \"MOCK\", 18)),\n            0\n        );\n    }\n}\n\ncontract CREATE3Test is DSTestPlus {\n    function testDeployERC20() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(\n                salt,\n                abi.encodePacked(type(MockERC20).creationCode, abi.encode(\"Mock Token\", \"MOCK\", 18)),\n                0\n            )\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), \"Mock Token\");\n        assertEq(deployed.symbol(), \"MOCK\");\n        assertEq(deployed.decimals(), 18);\n    }\n\n    function testPredictDeployERC20() public {\n        bytes32 salt = keccak256(bytes(\"A salt!\"));\n        Factory factory = new Factory();\n\n        MockERC20 deployed = MockERC20(\n            factory.deploy(salt)\n        );\n    \n        assertEq(address(deployed), CREATE3.getDeployed(salt, address(factory)));\n        assertTrue(address(deployed) != CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), \"Mock Token\");\n        assertEq(deployed.symbol(), \"MOCK\");\n        assertEq(deployed.decimals(), 18);\n    }\n\n    function testFailDoubleDeploySameBytecode() public {\n        bytes32 salt = keccak256(bytes(\"Salty...\"));\n\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode() public {\n        bytes32 salt = keccak256(bytes(\"and sweet!\"));\n\n        CREATE3.deploy(salt, type(WETH).creationCode, 0);\n        CREATE3.deploy(salt, type(MockAuthChild).creationCode, 0);\n    }\n\n    function testDeployERC20(\n        bytes32 salt,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 deployed = MockERC20(\n            CREATE3.deploy(salt, abi.encodePacked(type(MockERC20).creationCode, abi.encode(name, symbol, decimals)), 0)\n        );\n\n        assertEq(address(deployed), CREATE3.getDeployed(salt));\n\n        assertEq(deployed.name(), name);\n        assertEq(deployed.symbol(), symbol);\n        assertEq(deployed.decimals(), decimals);\n    }\n\n    function testFailDoubleDeploySameBytecode(bytes32 salt, bytes calldata bytecode) public {\n        CREATE3.deploy(salt, bytecode, 0);\n        CREATE3.deploy(salt, bytecode, 0);\n    }\n\n    function testFailDoubleDeployDifferentBytecode(\n        bytes32 salt,\n        bytes calldata bytecode1,\n        bytes calldata bytecode2\n    ) public {\n        CREATE3.deploy(salt, bytecode1, 0);\n        CREATE3.deploy(salt, bytecode2, 0);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/DSTestPlus.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\ncontract DSTestPlusTest is DSTestPlus {\n    function testBound() public {\n        assertEq(bound(0, 69, 69), 69);\n        assertEq(bound(0, 68, 69), 68);\n        assertEq(bound(5, 0, 4), 0);\n        assertEq(bound(9999, 1337, 6666), 6006);\n        assertEq(bound(0, type(uint256).max - 6, type(uint256).max), type(uint256).max - 6);\n        assertEq(bound(6, type(uint256).max - 6, type(uint256).max), type(uint256).max);\n    }\n\n    function testFailBoundMinBiggerThanMax() public {\n        bound(5, 100, 10);\n    }\n\n    function testRelApproxEqBothZeroesPasses() public {\n        assertRelApproxEq(0, 0, 1e18);\n        assertRelApproxEq(0, 0, 0);\n    }\n\n    function testBound(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (min > max) (min, max) = (max, min);\n\n        uint256 bounded = bound(num, min, max);\n\n        assertGe(bounded, min);\n        assertLe(bounded, max);\n    }\n\n    function testFailBoundMinBiggerThanMax(\n        uint256 num,\n        uint256 min,\n        uint256 max\n    ) public {\n        if (max == min) {\n            unchecked {\n                min++; // Overflow is handled below.\n            }\n        }\n\n        if (max > min) (min, max) = (max, min);\n\n        bound(num, min, max);\n    }\n\n    function testBrutalizeMemory() public brutalizeMemory(\"FEEDFACECAFEBEEFFEEDFACECAFEBEEF\") {\n        bytes32 scratchSpace1;\n        bytes32 scratchSpace2;\n        bytes32 freeMem1;\n        bytes32 freeMem2;\n\n        assembly {\n            scratchSpace1 := mload(0)\n            scratchSpace2 := mload(32)\n            freeMem1 := mload(mload(0x40))\n            freeMem2 := mload(add(mload(0x40), 32))\n        }\n\n        assertGt(uint256(freeMem1), 0);\n        assertGt(uint256(freeMem2), 0);\n        assertGt(uint256(scratchSpace1), 0);\n        assertGt(uint256(scratchSpace2), 0);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/ERC1155.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC1155} from \"./utils/mocks/MockERC1155.sol\";\n\nimport {ERC1155TokenReceiver} from \"../tokens/ERC1155.sol\";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;\n    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), \"testing 123\");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](5);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](5);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, \"testing 123\");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, \"\");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256[](5);\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, \"testing 123\");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), \"testing 123\");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, \"\");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, \"\");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, \"testing 123\");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), \"testing 123\");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address[](5);\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, \"\");\n        token.mint(address(0xCAFE), 1338, 200, \"\");\n        token.mint(address(0xFACE), 1339, 300, \"\");\n        token.mint(address(0xDEAD), 1340, 400, \"\");\n        token.mint(address(0xFEED), 1341, 500, \"\");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, \"\");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, \"\");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, \"\");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, \"\");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, \"\");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, \"\");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, \"\");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, \"\");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](5);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, \"\");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256[](4);\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, \"\");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, \"\");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, \"\");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256[](4);\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, \"\");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256[](5);\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256[](5);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256[](5);\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256[](4);\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, \"\");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address[](5);\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256[](4);\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        if (to == from) {\n            assertEq(token.balanceOf(to, id), mintAmount);\n        } else {\n            assertEq(token.balanceOf(to, id), transferAmount);\n            assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n        }\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i < normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address[](minLength);\n        uint256[] memory normalizedIds = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) || tos[i].code.length > 0 ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i < normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256[](minLength);\n        uint256[] memory normalizedMintAmounts = new uint256[](minLength);\n        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);\n\n        for (uint256 i = 0; i < minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/ERC20.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testFailPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline() public {\n        uint256 oldTimestamp = block.timestamp;\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, oldTimestamp))\n                )\n            )\n        );\n\n        hevm.warp(block.timestamp + 1);\n        token.permit(owner, address(0xCAFE), 1e18, oldTimestamp, v, r, s);\n    }\n\n    function testFailPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMetadata(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(\n        uint248 privKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        token.burn(to, burnAmount);\n    }\n\n    function testFailTransferInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        token.transfer(to, sendAmount);\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        token.transferFrom(from, to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        hevm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testFailPermitBadNonce(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint256 nonce\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitBadDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        deadline = bound(deadline, 0, block.timestamp - 1);\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitReplay(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/ERC4626.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {MockERC4626} from \"./utils/mocks/MockERC4626.sol\";\n\ncontract ERC4626Test is DSTestPlus {\n    MockERC20 underlying;\n    MockERC4626 vault;\n\n    function setUp() public {\n        underlying = new MockERC20(\"Mock Token\", \"TKN\", 18);\n        vault = new MockERC4626(underlying, \"Mock Token Vault\", \"vwTKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(vault.name(), \"Mock Token Vault\");\n        assertEq(vault.symbol(), \"vwTKN\");\n        assertEq(vault.decimals(), 18);\n    }\n\n    function testMetadata(string calldata name, string calldata symbol) public {\n        MockERC4626 vlt = new MockERC4626(underlying, name, symbol);\n        assertEq(vlt.name(), name);\n        assertEq(vlt.symbol(), symbol);\n        assertEq(address(vlt.asset()), address(underlying));\n    }\n\n    function testSingleDepositWithdraw(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceUnderlyingAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), aliceUnderlyingAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceUnderlyingAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        hevm.prank(alice);\n        uint256 aliceShareAmount = vault.deposit(aliceUnderlyingAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial deposit.\n        assertEq(aliceUnderlyingAmount, aliceShareAmount);\n        assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n        assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        vault.withdraw(aliceUnderlyingAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testSingleMintRedeem(uint128 amount) public {\n        if (amount == 0) amount = 1;\n\n        uint256 aliceShareAmount = amount;\n\n        address alice = address(0xABCD);\n\n        underlying.mint(alice, aliceShareAmount);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), aliceShareAmount);\n        assertEq(underlying.allowance(alice, address(vault)), aliceShareAmount);\n\n        uint256 alicePreDepositBal = underlying.balanceOf(alice);\n\n        hevm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(aliceShareAmount, alice);\n\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect exchange rate to be 1:1 on initial mint.\n        assertEq(aliceShareAmount, aliceUnderlyingAmount);\n        assertEq(vault.previewWithdraw(aliceShareAmount), aliceUnderlyingAmount);\n        assertEq(vault.previewDeposit(aliceUnderlyingAmount), aliceShareAmount);\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceUnderlyingAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal - aliceUnderlyingAmount);\n\n        hevm.prank(alice);\n        vault.redeem(aliceShareAmount, alice, alice);\n\n        assertEq(vault.beforeWithdrawHookCalledCounter(), 1);\n\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(underlying.balanceOf(alice), alicePreDepositBal);\n    }\n\n    function testMultipleMintDepositRedeemWithdraw() public {\n        // Scenario:\n        // A = Alice, B = Bob\n        //  ________________________________________________________\n        // | Vault shares | A share | A assets | B share | B assets |\n        // |========================================================|\n        // | 1. Alice mints 2000 shares (costs 2000 tokens)         |\n        // |--------------|---------|----------|---------|----------|\n        // |         2000 |    2000 |     2000 |       0 |        0 |\n        // |--------------|---------|----------|---------|----------|\n        // | 2. Bob deposits 4000 tokens (mints 4000 shares)        |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     2000 |    4000 |     4000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 3. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)...         |\n        // |--------------|---------|----------|---------|----------|\n        // |         6000 |    2000 |     3000 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 4. Alice deposits 2000 tokens (mints 1333 shares)      |\n        // |--------------|---------|----------|---------|----------|\n        // |         7333 |    3333 |     4999 |    4000 |     6000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 5. Bob mints 2000 shares (costs 3001 assets)           |\n        // |    NOTE: Bob's assets spent got rounded up             |\n        // |    NOTE: Alice's vault assets got rounded up           |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     5000 |    6000 |     9000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 6. Vault mutates by +3000 tokens...                    |\n        // |    (simulated yield returned from strategy)            |\n        // |    NOTE: Vault holds 17001 tokens, but sum of          |\n        // |          assetsOf() is 17000.                          |\n        // |--------------|---------|----------|---------|----------|\n        // |         9333 |    3333 |     6071 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 7. Alice redeem 1333 shares (2428 assets)              |\n        // |--------------|---------|----------|---------|----------|\n        // |         8000 |    2000 |     3643 |    6000 |    10929 |\n        // |--------------|---------|----------|---------|----------|\n        // | 8. Bob withdraws 2928 assets (1608 shares)             |\n        // |--------------|---------|----------|---------|----------|\n        // |         6392 |    2000 |     3643 |    4392 |     8000 |\n        // |--------------|---------|----------|---------|----------|\n        // | 9. Alice withdraws 3643 assets (2000 shares)           |\n        // |    NOTE: Bob's assets have been rounded back up        |\n        // |--------------|---------|----------|---------|----------|\n        // |         4392 |       0 |        0 |    4392 |     8001 |\n        // |--------------|---------|----------|---------|----------|\n        // | 10. Bob redeem 4392 shares (8001 tokens)               |\n        // |--------------|---------|----------|---------|----------|\n        // |            0 |       0 |        0 |       0 |        0 |\n        // |______________|_________|__________|_________|__________|\n\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n\n        uint256 mutationUnderlyingAmount = 3000;\n\n        underlying.mint(alice, 4000);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), 4000);\n\n        assertEq(underlying.allowance(alice, address(vault)), 4000);\n\n        underlying.mint(bob, 7001);\n\n        hevm.prank(bob);\n        underlying.approve(address(vault), 7001);\n\n        assertEq(underlying.allowance(bob, address(vault)), 7001);\n\n        // 1. Alice mints 2000 shares (costs 2000 tokens)\n        hevm.prank(alice);\n        uint256 aliceUnderlyingAmount = vault.mint(2000, alice);\n\n        uint256 aliceShareAmount = vault.previewDeposit(aliceUnderlyingAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 1);\n\n        // Expect to have received the requested mint amount.\n        assertEq(aliceShareAmount, 2000);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), aliceUnderlyingAmount);\n        assertEq(vault.convertToShares(aliceUnderlyingAmount), vault.balanceOf(alice));\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(aliceUnderlyingAmount, 2000);\n\n        // Sanity check.\n        assertEq(vault.totalSupply(), aliceShareAmount);\n        assertEq(vault.totalAssets(), aliceUnderlyingAmount);\n\n        // 2. Bob deposits 4000 tokens (mints 4000 shares)\n        hevm.prank(bob);\n        uint256 bobShareAmount = vault.deposit(4000, bob);\n        uint256 bobUnderlyingAmount = vault.previewWithdraw(bobShareAmount);\n        assertEq(vault.afterDepositHookCalledCounter(), 2);\n\n        // Expect to have received the requested underlying amount.\n        assertEq(bobUnderlyingAmount, 4000);\n        assertEq(vault.balanceOf(bob), bobShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), bobUnderlyingAmount);\n        assertEq(vault.convertToShares(bobUnderlyingAmount), vault.balanceOf(bob));\n\n        // Expect a 1:1 ratio before mutation.\n        assertEq(bobShareAmount, bobUnderlyingAmount);\n\n        // Sanity check.\n        uint256 preMutationShareBal = aliceShareAmount + bobShareAmount;\n        uint256 preMutationBal = aliceUnderlyingAmount + bobUnderlyingAmount;\n        assertEq(vault.totalSupply(), preMutationShareBal);\n        assertEq(vault.totalAssets(), preMutationBal);\n        assertEq(vault.totalSupply(), 6000);\n        assertEq(vault.totalAssets(), 6000);\n\n        // 3. Vault mutates by +3000 tokens...                    |\n        //    (simulated yield returned from strategy)...\n        // The Vault now contains more tokens than deposited which causes the exchange rate to change.\n        // Alice share is 33.33% of the Vault, Bob 66.66% of the Vault.\n        // Alice's share count stays the same but the underlying amount changes from 2000 to 3000.\n        // Bob's share count stays the same but the underlying amount changes from 4000 to 6000.\n        underlying.mint(address(vault), mutationUnderlyingAmount);\n        assertEq(vault.totalSupply(), preMutationShareBal);\n        assertEq(vault.totalAssets(), preMutationBal + mutationUnderlyingAmount);\n        assertEq(vault.balanceOf(alice), aliceShareAmount);\n        assertEq(\n            vault.convertToAssets(vault.balanceOf(alice)),\n            aliceUnderlyingAmount + (mutationUnderlyingAmount / 3) * 1\n        );\n        assertEq(vault.balanceOf(bob), bobShareAmount);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), bobUnderlyingAmount + (mutationUnderlyingAmount / 3) * 2);\n\n        // 4. Alice deposits 2000 tokens (mints 1333 shares)\n        hevm.prank(alice);\n        vault.deposit(2000, alice);\n\n        assertEq(vault.totalSupply(), 7333);\n        assertEq(vault.balanceOf(alice), 3333);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 4999);\n        assertEq(vault.balanceOf(bob), 4000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 6000);\n\n        // 5. Bob mints 2000 shares (costs 3001 assets)\n        // NOTE: Bob's assets spent got rounded up\n        // NOTE: Alices's vault assets got rounded up\n        hevm.prank(bob);\n        vault.mint(2000, bob);\n\n        assertEq(vault.totalSupply(), 9333);\n        assertEq(vault.balanceOf(alice), 3333);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 5000);\n        assertEq(vault.balanceOf(bob), 6000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 9000);\n\n        // Sanity checks:\n        // Alice and bob should have spent all their tokens now\n        assertEq(underlying.balanceOf(alice), 0);\n        assertEq(underlying.balanceOf(bob), 0);\n        // Assets in vault: 4k (alice) + 7k (bob) + 3k (yield) + 1 (round up)\n        assertEq(vault.totalAssets(), 14001);\n\n        // 6. Vault mutates by +3000 tokens\n        // NOTE: Vault holds 17001 tokens, but sum of assetsOf() is 17000.\n        underlying.mint(address(vault), mutationUnderlyingAmount);\n        assertEq(vault.totalAssets(), 17001);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 6071);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 10929);\n\n        // 7. Alice redeem 1333 shares (2428 assets)\n        hevm.prank(alice);\n        vault.redeem(1333, alice, alice);\n\n        assertEq(underlying.balanceOf(alice), 2428);\n        assertEq(vault.totalSupply(), 8000);\n        assertEq(vault.totalAssets(), 14573);\n        assertEq(vault.balanceOf(alice), 2000);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 3643);\n        assertEq(vault.balanceOf(bob), 6000);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 10929);\n\n        // 8. Bob withdraws 2929 assets (1608 shares)\n        hevm.prank(bob);\n        vault.withdraw(2929, bob, bob);\n\n        assertEq(underlying.balanceOf(bob), 2929);\n        assertEq(vault.totalSupply(), 6392);\n        assertEq(vault.totalAssets(), 11644);\n        assertEq(vault.balanceOf(alice), 2000);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 3643);\n        assertEq(vault.balanceOf(bob), 4392);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 8000);\n\n        // 9. Alice withdraws 3643 assets (2000 shares)\n        // NOTE: Bob's assets have been rounded back up\n        hevm.prank(alice);\n        vault.withdraw(3643, alice, alice);\n\n        assertEq(underlying.balanceOf(alice), 6071);\n        assertEq(vault.totalSupply(), 4392);\n        assertEq(vault.totalAssets(), 8001);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(vault.balanceOf(bob), 4392);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 8001);\n\n        // 10. Bob redeem 4392 shares (8001 tokens)\n        hevm.prank(bob);\n        vault.redeem(4392, bob, bob);\n        assertEq(underlying.balanceOf(bob), 10930);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(alice)), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(bob)), 0);\n\n        // Sanity check\n        assertEq(underlying.balanceOf(address(vault)), 0);\n    }\n\n    function testFailDepositWithNotEnoughApproval() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n        assertEq(underlying.allowance(address(this), address(vault)), 0.5e18);\n\n        vault.deposit(1e18, address(this));\n    }\n\n    function testFailWithdrawWithNotEnoughUnderlyingAmount() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testFailRedeemWithNotEnoughShareAmount() public {\n        underlying.mint(address(this), 0.5e18);\n        underlying.approve(address(vault), 0.5e18);\n\n        vault.deposit(0.5e18, address(this));\n\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testFailWithdrawWithNoUnderlyingAmount() public {\n        vault.withdraw(1e18, address(this), address(this));\n    }\n\n    function testFailRedeemWithNoShareAmount() public {\n        vault.redeem(1e18, address(this), address(this));\n    }\n\n    function testFailDepositWithNoApproval() public {\n        vault.deposit(1e18, address(this));\n    }\n\n    function testFailMintWithNoApproval() public {\n        vault.mint(1e18, address(this));\n    }\n\n    function testFailDepositZero() public {\n        vault.deposit(0, address(this));\n    }\n\n    function testMintZero() public {\n        vault.mint(0, address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testFailRedeemZero() public {\n        vault.redeem(0, address(this), address(this));\n    }\n\n    function testWithdrawZero() public {\n        vault.withdraw(0, address(this), address(this));\n\n        assertEq(vault.balanceOf(address(this)), 0);\n        assertEq(vault.convertToAssets(vault.balanceOf(address(this))), 0);\n        assertEq(vault.totalSupply(), 0);\n        assertEq(vault.totalAssets(), 0);\n    }\n\n    function testVaultInteractionsForSomeoneElse() public {\n        // init 2 users with a 1e18 balance\n        address alice = address(0xABCD);\n        address bob = address(0xDCBA);\n        underlying.mint(alice, 1e18);\n        underlying.mint(bob, 1e18);\n\n        hevm.prank(alice);\n        underlying.approve(address(vault), 1e18);\n\n        hevm.prank(bob);\n        underlying.approve(address(vault), 1e18);\n\n        // alice deposits 1e18 for bob\n        hevm.prank(alice);\n        vault.deposit(1e18, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(alice), 0);\n\n        // bob mint 1e18 for alice\n        hevm.prank(bob);\n        vault.mint(1e18, alice);\n        assertEq(vault.balanceOf(alice), 1e18);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 0);\n\n        // alice redeem 1e18 for bob\n        hevm.prank(alice);\n        vault.redeem(1e18, bob, alice);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 1e18);\n        assertEq(underlying.balanceOf(bob), 1e18);\n\n        // bob withdraw 1e18 for alice\n        hevm.prank(bob);\n        vault.withdraw(1e18, alice, bob);\n\n        assertEq(vault.balanceOf(alice), 0);\n        assertEq(vault.balanceOf(bob), 0);\n        assertEq(underlying.balanceOf(alice), 1e18);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/ERC6909.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC6909} from \"./utils/mocks/MockERC6909.sol\";\n\ncontract ERC6909Test is DSTestPlus {\n    MockERC6909 token;\n\n    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;\n    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC6909();\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337, 100);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100);\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testSetOperator() public {\n        token.setOperator(address(0xBEEF), true);\n\n        assertTrue(token.isOperator(address(this), address(0xBEEF)));\n    }\n\n    function testApprove() public {\n        token.approve(address(0xBEEF), 1337, 100);\n\n        assertEq(token.allowance(address(this), address(0xBEEF), 1337), 100);\n    }\n\n    function testTransfer() public {\n        address sender = address(0xABCD);\n\n        token.mint(sender, 1337, 100);\n\n        hevm.prank(sender);\n        token.transfer(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(sender, 1337), 30);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n    }\n\n    function testTransferFromWithApproval() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        token.mint(sender, 1337, 100);\n\n        hevm.prank(sender);\n        token.approve(address(this), 1337, 100);\n\n        token.transferFrom(sender, receiver, 1337, 70);\n\n        assertEq(token.allowance(sender, address(this), 1337), 30);\n        assertEq(token.balanceOf(sender, 1337), 30);\n        assertEq(token.balanceOf(receiver, 1337), 70);\n    }\n\n    function testTransferFromWithInfiniteApproval() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        token.mint(sender, 1337, 100);\n\n        hevm.prank(sender);\n        token.approve(address(this), 1337, type(uint256).max);\n\n        token.transferFrom(sender, receiver, 1337, 70);\n\n        assertEq(token.allowance(sender, address(this), 1337), type(uint256).max);\n        assertEq(token.balanceOf(sender, 1337), 30);\n        assertEq(token.balanceOf(receiver, 1337), 70);\n    }\n\n    function testTransferFromAsOperator() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        token.mint(sender, 1337, 100);\n\n        hevm.prank(sender);\n        token.setOperator(address(this), true);\n\n        token.transferFrom(sender, receiver, 1337, 70);\n\n        assertEq(token.balanceOf(sender, 1337), 30);\n        assertEq(token.balanceOf(receiver, 1337), 70);\n    }\n\n    function testFailMintBalanceOverflow() public {\n        token.mint(address(0xDEAD), 1337, type(uint256).max);\n        token.mint(address(0xDEAD), 1337, 1);\n    }\n\n    function testFailTransferBalanceUnderflow() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, 1337, 1);\n    }\n\n    function testFailTransferBalanceOverflow() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        token.mint(sender, 1337, type(uint256).max);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, 1337, type(uint256).max);\n\n        token.mint(sender, 1337, 1);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, 1337, 1);\n    }\n\n    function testFailTransferFromBalanceUnderflow() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, 1337, 1);\n    }\n\n    function testFailTransferFromBalanceOverflow() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        token.mint(sender, 1337, type(uint256).max);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, 1337, type(uint256).max);\n\n        token.mint(sender, 1337, 1);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, 1337, 1);\n    }\n\n    function testFailTransferFromNotAuthorized() public {\n        address sender = address(0xABCD);\n        address receiver = address(0xBEEF);\n\n        token.mint(sender, 1337, 100);\n\n        token.transferFrom(sender, receiver, 1337, 100);\n    }\n\n    function testMint(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public {\n        token.mint(receiver, id, amount);\n\n        assertEq(token.balanceOf(receiver, id), amount);\n    }\n\n    function testBurn(\n        address sender,\n        uint256 id,\n        uint256 amount\n    ) public {\n        token.mint(sender, id, amount);\n        token.burn(sender, id, amount);\n\n        assertEq(token.balanceOf(sender, id), 0);\n    }\n\n    function testSetOperator(address operator, bool approved) public {\n        token.setOperator(operator, approved);\n\n        assertBoolEq(token.isOperator(address(this), operator), approved);\n    }\n\n    function testApprove(\n        address spender,\n        uint256 id,\n        uint256 amount\n    ) public {\n        token.approve(spender, id, amount);\n\n        assertEq(token.allowance(address(this), spender, id), amount);\n    }\n\n    function testTransfer(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(sender, id, mintAmount);\n\n        hevm.prank(sender);\n        token.transfer(receiver, id, transferAmount);\n\n        if (sender == receiver) {\n            assertEq(token.balanceOf(sender, id), mintAmount);\n        } else {\n            assertEq(token.balanceOf(sender, id), mintAmount - transferAmount);\n            assertEq(token.balanceOf(receiver, id), transferAmount);\n        }\n    }\n\n    function testTransferFromWithApproval(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(sender, id, mintAmount);\n\n        hevm.prank(sender);\n        token.approve(address(this), id, mintAmount);\n\n        token.transferFrom(sender, receiver, id, transferAmount);\n\n        if (mintAmount == type(uint256).max) {\n            assertEq(token.allowance(sender, address(this), id), type(uint256).max);\n        } else {\n            assertEq(token.allowance(sender, address(this), id), mintAmount - transferAmount);\n        }\n\n        if (sender == receiver) {\n            assertEq(token.balanceOf(sender, id), mintAmount);\n        } else {\n            assertEq(token.balanceOf(sender, id), mintAmount - transferAmount);\n            assertEq(token.balanceOf(receiver, id), transferAmount);\n        }\n    }\n\n    function testTransferFromWithInfiniteApproval(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(sender, id, mintAmount);\n\n        hevm.prank(sender);\n        token.approve(address(this), id, type(uint256).max);\n\n        token.transferFrom(sender, receiver, id, transferAmount);\n\n        assertEq(token.allowance(sender, address(this), id), type(uint256).max);\n\n        if (sender == receiver) {\n            assertEq(token.balanceOf(sender, id), mintAmount);\n        } else {\n            assertEq(token.balanceOf(sender, id), mintAmount - transferAmount);\n            assertEq(token.balanceOf(receiver, id), transferAmount);\n        }\n    }\n\n    function testTransferFromAsOperator(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(sender, id, mintAmount);\n\n        hevm.prank(sender);\n        token.setOperator(address(this), true);\n\n        token.transferFrom(sender, receiver, id, transferAmount);\n\n        if (sender == receiver) {\n            assertEq(token.balanceOf(sender, id), mintAmount);\n        } else {\n            assertEq(token.balanceOf(sender, id), mintAmount - transferAmount);\n            assertEq(token.balanceOf(receiver, id), transferAmount);\n        }\n    }\n\n    function testFailTransferBalanceUnderflow(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 1, type(uint256).max);\n\n        hevm.prank(sender);\n        token.transfer(receiver, id, amount);\n    }\n\n    function testFailTransferBalanceOverflow(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 1, type(uint256).max);\n        uint256 overflowAmount = type(uint256).max - amount + 1;\n\n        token.mint(sender, id, amount);\n\n        hevm.prank(sender);\n        token.transfer(receiver, id, amount);\n\n        token.mint(sender, id, overflowAmount);\n\n        hevm.prank(sender);\n        token.transfer(receiver, id, overflowAmount);\n    }\n\n    function testFailTransferFromBalanceUnderflow(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 1, type(uint256).max);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, id, amount);\n    }\n\n    function testFailTransferFromBalanceOverflow(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 1, type(uint256).max);\n        uint256 overflowAmount = type(uint256).max - amount + 1;\n\n        token.mint(sender, id, amount);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, id, amount);\n\n        token.mint(sender, id, overflowAmount);\n\n        hevm.prank(sender);\n        token.transferFrom(sender, receiver, id, overflowAmount);\n    }\n\n    function testFailTransferFromNotAuthorized(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 1, type(uint256).max);\n\n        token.mint(sender, id, amount);\n\n        token.transferFrom(sender, receiver, id, amount);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/ERC721.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nimport {ERC721TokenReceiver} from \"../tokens/ERC721.sol\";\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        bytes calldata _data\n    ) public virtual override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract ERC721Test is DSTestPlus {\n    MockERC721 token;\n\n    function setUp() public {\n        token = new MockERC721(\"Token\", \"TKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337);\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApprove() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0xBEEF));\n    }\n\n    function testApproveBurn() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(1337), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.approve(address(this), 1337);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337, \"testing 123\");\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"testing 123\");\n    }\n\n    function testSafeMintToEOA() public {\n        token.safeMint(address(0xBEEF), 1337);\n\n        assertEq(token.ownerOf(1337), address(address(0xBEEF)));\n        assertEq(token.balanceOf(address(address(0xBEEF))), 1);\n    }\n\n    function testSafeMintToERC721Recipient() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337);\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337, \"testing 123\");\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"testing 123\");\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337);\n    }\n\n    function testFailDoubleMint() public {\n        token.mint(address(0xBEEF), 1337);\n        token.mint(address(0xBEEF), 1337);\n    }\n\n    function testFailBurnUnMinted() public {\n        token.burn(1337);\n    }\n\n    function testFailDoubleBurn() public {\n        token.mint(address(0xBEEF), 1337);\n\n        token.burn(1337);\n        token.burn(1337);\n    }\n\n    function testFailApproveUnMinted() public {\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailApproveUnAuthorized() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromUnOwned() public {\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromWrongFrom() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromToZero() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0), 1337);\n    }\n\n    function testFailTransferFromNotOwner() public {\n        token.mint(address(0xFEED), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToNonERC721Recipient() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailBalanceOfZeroAddress() public view {\n        token.balanceOf(address(0));\n    }\n\n    function testFailOwnerOfUnminted() public view {\n        token.ownerOf(1337);\n    }\n\n    function testMetadata(string memory name, string memory symbol) public {\n        MockERC721 tkn = new MockERC721(name, symbol);\n\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n    }\n\n    function testMint(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.ownerOf(id), to);\n    }\n\n    function testBurn(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.burn(id);\n\n        assertEq(token.balanceOf(to), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApprove(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.approve(to, id);\n\n        assertEq(token.getApproved(id), to);\n    }\n\n    function testApproveBurn(address to, uint256 id) public {\n        token.mint(address(this), id);\n\n        token.approve(address(to), id);\n\n        token.burn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(id), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testTransferFrom(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.approve(address(this), id);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id, address to) public {\n        if (to == address(0) || to == address(this)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        address from = address(0xABCD);\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), data);\n    }\n\n    function testSafeMintToEOA(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.safeMint(to, id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), data);\n    }\n\n    function testFailMintToZero(uint256 id) public {\n        token.mint(address(0), id);\n    }\n\n    function testFailDoubleMint(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.mint(to, id);\n    }\n\n    function testFailBurnUnMinted(uint256 id) public {\n        token.burn(id);\n    }\n\n    function testFailDoubleBurn(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        token.burn(id);\n        token.burn(id);\n    }\n\n    function testFailApproveUnMinted(uint256 id, address to) public {\n        token.approve(to, id);\n    }\n\n    function testFailApproveUnAuthorized(\n        address owner,\n        uint256 id,\n        address to\n    ) public {\n        if (owner == address(0) || owner == address(this)) owner = address(0xBEEF);\n\n        token.mint(owner, id);\n\n        token.approve(to, id);\n    }\n\n    function testFailTransferFromUnOwned(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromWrongFrom(\n        address owner,\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (owner == address(0)) to = address(0xBEEF);\n        if (from == owner) revert();\n\n        token.mint(owner, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromToZero(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), address(0), id);\n    }\n\n    function testFailTransferFromNotOwner(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (from == address(this)) from = address(0xBEEF);\n\n        token.mint(from, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data)\n        public\n    {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToNonERC721Recipient(uint256 id) public {\n        token.safeMint(address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient(uint256 id) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailOwnerOfUnminted(uint256 id) public view {\n        token.ownerOf(id);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/FixedPointMathLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\ncontract FixedPointMathLibTest is DSTestPlus {\n    function testMulWadDown() public {\n        assertEq(FixedPointMathLib.mulWadDown(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadDown(369, 271), 0);\n    }\n\n    function testMulWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadDown(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadDown(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadDown(0, 0), 0);\n    }\n\n    function testMulWadUp() public {\n        assertEq(FixedPointMathLib.mulWadUp(2.5e18, 0.5e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.mulWadUp(369, 271), 1);\n    }\n\n    function testMulWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulWadUp(0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulWadUp(1e18, 0), 0);\n        assertEq(FixedPointMathLib.mulWadUp(0, 0), 0);\n    }\n\n    function testDivWadDown() public {\n        assertEq(FixedPointMathLib.divWadDown(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadDown(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadDown(2, 100000000000000e18), 0);\n    }\n\n    function testDivWadDownEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadDown(0, 1e18), 0);\n    }\n\n    function testFailDivWadDownZeroDenominator() public pure {\n        FixedPointMathLib.divWadDown(1e18, 0);\n    }\n\n    function testDivWadUp() public {\n        assertEq(FixedPointMathLib.divWadUp(1.25e18, 0.5e18), 2.5e18);\n        assertEq(FixedPointMathLib.divWadUp(3e18, 1e18), 3e18);\n        assertEq(FixedPointMathLib.divWadUp(2, 100000000000000e18), 1);\n    }\n\n    function testDivWadUpEdgeCases() public {\n        assertEq(FixedPointMathLib.divWadUp(0, 1e18), 0);\n    }\n\n    function testFailDivWadUpZeroDenominator() public pure {\n        FixedPointMathLib.divWadUp(1e18, 0);\n    }\n\n    function testMulDivDown() public {\n        assertEq(FixedPointMathLib.mulDivDown(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivDown(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivDown(369, 271, 1e2), 999);\n\n        assertEq(FixedPointMathLib.mulDivDown(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivDown(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivDown(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivDown(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivDown(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivDownEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivDown(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivDown(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivDownZeroDenominator() public pure {\n        FixedPointMathLib.mulDivDown(1e18, 1e18, 0);\n    }\n\n    function testMulDivUp() public {\n        assertEq(FixedPointMathLib.mulDivUp(2.5e27, 0.5e27, 1e27), 1.25e27);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e18, 0.5e18, 1e18), 1.25e18);\n        assertEq(FixedPointMathLib.mulDivUp(2.5e8, 0.5e8, 1e8), 1.25e8);\n        assertEq(FixedPointMathLib.mulDivUp(369, 271, 1e2), 1000);\n\n        assertEq(FixedPointMathLib.mulDivUp(1e27, 1e27, 2e27), 0.5e27);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 1e18, 2e18), 0.5e18);\n        assertEq(FixedPointMathLib.mulDivUp(1e8, 1e8, 2e8), 0.5e8);\n\n        assertEq(FixedPointMathLib.mulDivUp(2e27, 3e27, 2e27), 3e27);\n        assertEq(FixedPointMathLib.mulDivUp(3e18, 2e18, 3e18), 2e18);\n        assertEq(FixedPointMathLib.mulDivUp(2e8, 3e8, 2e8), 3e8);\n    }\n\n    function testMulDivUpEdgeCases() public {\n        assertEq(FixedPointMathLib.mulDivUp(0, 1e18, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(1e18, 0, 1e18), 0);\n        assertEq(FixedPointMathLib.mulDivUp(0, 0, 1e18), 0);\n    }\n\n    function testFailMulDivUpZeroDenominator() public pure {\n        FixedPointMathLib.mulDivUp(1e18, 1e18, 0);\n    }\n\n    function testRPow() public {\n        assertEq(FixedPointMathLib.rpow(2e27, 2, 1e27), 4e27);\n        assertEq(FixedPointMathLib.rpow(2e18, 2, 1e18), 4e18);\n        assertEq(FixedPointMathLib.rpow(2e8, 2, 1e8), 4e8);\n        assertEq(FixedPointMathLib.rpow(8, 3, 1), 512);\n    }\n\n    function testSqrt() public {\n        assertEq(FixedPointMathLib.sqrt(0), 0);\n        assertEq(FixedPointMathLib.sqrt(1), 1);\n        assertEq(FixedPointMathLib.sqrt(2704), 52);\n        assertEq(FixedPointMathLib.sqrt(110889), 333);\n        assertEq(FixedPointMathLib.sqrt(32239684), 5678);\n        assertEq(FixedPointMathLib.sqrt(type(uint256).max), 340282366920938463463374607431768211455);\n    }\n\n    function testSqrtBackHashedSingle() public {\n        testSqrtBackHashed(123);\n    }\n\n    function testMulWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadDown(x, y), (x * y) / 1e18);\n    }\n\n    function testFailMulWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadDown(x, y);\n    }\n\n    function testMulWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * y overflows.\n        unchecked {\n            if (x != 0 && (x * y) / x != y) return;\n        }\n\n        assertEq(FixedPointMathLib.mulWadUp(x, y), x * y == 0 ? 0 : (x * y - 1) / 1e18 + 1);\n    }\n\n    function testFailMulWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulWadUp(x, y);\n    }\n\n    function testDivWadDown(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadDown(x, y), (x * 1e18) / y);\n    }\n\n    function testFailDivWadDownOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadDown(x, y);\n    }\n\n    function testFailDivWadDownZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadDown(x, 0);\n    }\n\n    function testDivWadUp(uint256 x, uint256 y) public {\n        // Ignore cases where x * WAD overflows or y is 0.\n        unchecked {\n            if (y == 0 || (x != 0 && (x * 1e18) / 1e18 != x)) return;\n        }\n\n        assertEq(FixedPointMathLib.divWadUp(x, y), x == 0 ? 0 : (x * 1e18 - 1) / y + 1);\n    }\n\n    function testFailDivWadUpOverflow(uint256 x, uint256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        FixedPointMathLib.divWadUp(x, y);\n    }\n\n    function testFailDivWadUpZeroDenominator(uint256 x) public pure {\n        FixedPointMathLib.divWadUp(x, 0);\n    }\n\n    function testMulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivDown(x, y, denominator), (x * y) / denominator);\n    }\n\n    function testFailMulDivDownOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivDown(x, y, denominator);\n    }\n\n    function testFailMulDivDownZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivDown(x, y, 0);\n    }\n\n    function testMulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(FixedPointMathLib.mulDivUp(x, y, denominator), x * y == 0 ? 0 : (x * y - 1) / denominator + 1);\n    }\n\n    function testFailMulDivUpOverflow(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) public pure {\n        // Ignore cases where x * y does not overflow or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x * y) / x == y) revert();\n        }\n\n        FixedPointMathLib.mulDivUp(x, y, denominator);\n    }\n\n    function testFailMulDivUpZeroDenominator(uint256 x, uint256 y) public pure {\n        FixedPointMathLib.mulDivUp(x, y, 0);\n    }\n\n    function testDifferentiallyFuzzSqrt(uint256 x) public {\n        assertEq(FixedPointMathLib.sqrt(x), uniswapSqrt(x));\n        assertEq(FixedPointMathLib.sqrt(x), abdkSqrt(x));\n    }\n\n    function testSqrt(uint256 x) public {\n        uint256 root = FixedPointMathLib.sqrt(x);\n        uint256 next = root + 1;\n\n        // Ignore cases where next * next overflows.\n        unchecked {\n            if (next * next < next) return;\n        }\n\n        assertTrue(root * root <= x && next * next > x);\n    }\n\n    function testSqrtBack(uint256 x) public {\n        unchecked {\n            x >>= 128;\n            while (x != 0) {\n                assertEq(FixedPointMathLib.sqrt(x * x), x);\n                x >>= 1;\n            }\n        }\n    }\n\n    function testSqrtBackHashed(uint256 x) public {\n        testSqrtBack(uint256(keccak256(abi.encode(x))));\n    }\n\n    function uniswapSqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function abdkSqrt(uint256 x) private pure returns (uint256) {\n        unchecked {\n            if (x == 0) return 0;\n            else {\n                uint256 xx = x;\n                uint256 r = 1;\n                if (xx >= 0x100000000000000000000000000000000) {\n                    xx >>= 128;\n                    r <<= 64;\n                }\n                if (xx >= 0x10000000000000000) {\n                    xx >>= 64;\n                    r <<= 32;\n                }\n                if (xx >= 0x100000000) {\n                    xx >>= 32;\n                    r <<= 16;\n                }\n                if (xx >= 0x10000) {\n                    xx >>= 16;\n                    r <<= 8;\n                }\n                if (xx >= 0x100) {\n                    xx >>= 8;\n                    r <<= 4;\n                }\n                if (xx >= 0x10) {\n                    xx >>= 4;\n                    r <<= 2;\n                }\n                if (xx >= 0x8) {\n                    r <<= 1;\n                }\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1;\n                r = (r + x / r) >> 1; // Seven iterations should be enough\n                uint256 r1 = x / r;\n                return r < r1 ? r : r1;\n            }\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/LibString.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {LibString} from \"../utils/LibString.sol\";\n\ncontract LibStringTest is DSTestPlus {\n    function testToString() public {\n        assertEq(LibString.toString(uint256(0)), \"0\");\n        assertEq(LibString.toString(uint256(1)), \"1\");\n        assertEq(LibString.toString(uint256(17)), \"17\");\n        assertEq(LibString.toString(uint256(99999999)), \"99999999\");\n        assertEq(LibString.toString(uint256(99999999999)), \"99999999999\");\n        assertEq(LibString.toString(uint256(2342343923423)), \"2342343923423\");\n        assertEq(LibString.toString(uint256(98765685434567)), \"98765685434567\");\n    }\n\n    function testToStringIntPositive() public {\n        assertEq(LibString.toString(int256(0)), \"0\");\n        assertEq(LibString.toString(int256(1)), \"1\");\n        assertEq(LibString.toString(int256(17)), \"17\");\n        assertEq(LibString.toString(int256(99999999)), \"99999999\");\n        assertEq(LibString.toString(int256(99999999999)), \"99999999999\");\n        assertEq(LibString.toString(int256(2342343923423)), \"2342343923423\");\n        assertEq(LibString.toString(int256(98765685434567)), \"98765685434567\");\n    }\n\n    function testToStringIntNegative() public {\n        assertEq(LibString.toString(int256(-0)), \"0\");\n        assertEq(LibString.toString(int256(-17)), \"-17\");\n        assertEq(LibString.toString(int256(-99999999)), \"-99999999\");\n        assertEq(LibString.toString(int256(-99999999999)), \"-99999999999\");\n        assertEq(LibString.toString(int256(-2342343923423)), \"-2342343923423\");\n        assertEq(LibString.toString(int256(-98765685434567)), \"-98765685434567\");\n    }\n\n    function testDifferentiallyFuzzToString(uint256 value, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        string memory libString = LibString.toString(value);\n        string memory oz = toStringOZ(value);\n\n        assertEq(bytes(libString).length, bytes(oz).length);\n        assertEq(libString, oz);\n    }\n\n    function testDifferentiallyFuzzToStringInt(int256 value, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        string memory libString = LibString.toString(value);\n        string memory oz = toStringOZ(value);\n\n        assertEq(bytes(libString).length, bytes(oz).length);\n        assertEq(libString, oz);\n    }\n\n    function testToStringOverwrite() public {\n        string memory str = LibString.toString(uint256(1));\n\n        bytes32 data;\n        bytes32 expected;\n\n        assembly {\n            // Imagine a high level allocation writing something to the current free memory.\n            // Should have sufficient higher order bits for this to be visible\n            mstore(mload(0x40), not(0))\n            // Correctly allocate 32 more bytes, to avoid more interference\n            mstore(0x40, add(mload(0x40), 32))\n            data := mload(add(str, 32))\n\n            // the expected value should be the uft-8 encoding of 1 (49),\n            // followed by clean bits. We achieve this by taking the value and\n            // shifting left to the end of the 32 byte word\n            expected := shl(248, 49)\n        }\n\n        assertEq(data, expected);\n    }\n\n    function testToStringDirty() public {\n        uint256 freememptr;\n        // Make the next 4 bytes of the free memory dirty\n        assembly {\n            let dirty := not(0)\n            freememptr := mload(0x40)\n            mstore(freememptr, dirty)\n            mstore(add(freememptr, 32), dirty)\n            mstore(add(freememptr, 64), dirty)\n            mstore(add(freememptr, 96), dirty)\n            mstore(add(freememptr, 128), dirty)\n        }\n        string memory str = LibString.toString(uint256(1));\n        uint256 len;\n        bytes32 data;\n        bytes32 expected;\n        assembly {\n            freememptr := str\n            len := mload(str)\n            data := mload(add(str, 32))\n            // the expected value should be the uft-8 encoding of 1 (49),\n            // followed by clean bits. We achieve this by taking the value and\n            // shifting left to the end of the 32 byte word\n            expected := shl(248, 49)\n        }\n        emit log_named_uint(\"str: \", freememptr);\n        emit log_named_uint(\"len: \", len);\n        emit log_named_bytes32(\"data: \", data);\n        assembly {\n            freememptr := mload(0x40)\n        }\n        emit log_named_uint(\"memptr: \", freememptr);\n\n        assertEq(data, expected);\n    }\n}\n\nfunction toStringOZ(int256 value) pure returns (string memory) {\n    return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toStringOZ(absOZ(value))));\n}\n\nfunction toStringOZ(uint256 value) pure returns (string memory) {\n    if (value == 0) {\n        return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n        digits++;\n        temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n        digits -= 1;\n        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n        value /= 10;\n    }\n    return string(buffer);\n}\n\nfunction absOZ(int256 n) pure returns (uint256) {\n    unchecked {\n        // must be unchecked in order to support `n = type(int256).min`\n        return uint256(n >= 0 ? n : -n);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/MerkleProofLib.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {MerkleProofLib} from \"../utils/MerkleProofLib.sol\";\n\ncontract MerkleProofLibTest is DSTestPlus {\n    function testVerifyEmptyMerkleProofSuppliedLeafAndRootSame() public {\n        bytes32[] memory proof;\n        assertBoolEq(this.verify(proof, 0x00, 0x00), true);\n    }\n\n    function testVerifyEmptyMerkleProofSuppliedLeafAndRootDifferent() public {\n        bytes32[] memory proof;\n        bytes32 leaf = \"a\";\n        assertBoolEq(this.verify(proof, 0x00, leaf), false);\n    }\n\n    function testValidProofSupplied() public {\n        // Merkle tree created from leaves ['a', 'b', 'c'].\n        // Leaf is 'a'.\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5510;\n        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;\n        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;\n        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;\n        assertBoolEq(this.verify(proof, root, leaf), true);\n    }\n\n    function testVerifyInvalidProofSupplied() public {\n        // Merkle tree created from leaves ['a', 'b', 'c'].\n        // Leaf is 'a'.\n        // Proof is same as testValidProofSupplied but last byte of first element is modified.\n        bytes32[] memory proof = new bytes32[](2);\n        proof[0] = 0xb5553de315e0edf504d9150af82dafa5c4667fa618ed0a6f19c69b41166c5511;\n        proof[1] = 0x0b42b6393c1f53060fe3ddbfcd7aadcca894465a5a438f69c87d790b2299b9b2;\n        bytes32 root = 0x5842148bc6ebeb52af882a317c765fccd3ae80589b21a9b8cbf21abb630e46a7;\n        bytes32 leaf = 0x3ac225168df54212a25c1c01fd35bebfea408fdac2e31ddd6f80a4bbf9a5f1cb;\n        assertBoolEq(this.verify(proof, root, leaf), false);\n    }\n\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) external pure returns (bool) {\n        return MerkleProofLib.verify(proof, root, leaf);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/MultiRolesAuthority.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {MultiRolesAuthority} from \"../auth/authorities/MultiRolesAuthority.sol\";\n\ncontract MultiRolesAuthorityTest is DSTestPlus {\n    MultiRolesAuthority multiRolesAuthority;\n\n    function setUp() public {\n        multiRolesAuthority = new MultiRolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(0, 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.isCapabilityPublic(0xBEEFCAFE));\n    }\n\n    function testSetTargetCustomAuthority() public {\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xBEEF), Authority(address(0xCAFE)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0xCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xBEEF), Authority(address(0)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(address(0xBEEF))), address(0));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthority() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesPublicCapability() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, false);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setPublicCapability(0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesUserWithRole() public {\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setTargetCustomAuthority(address(0xCAFE), Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setRoleCapability(0, 0xBEEFCAFE, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        multiRolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(multiRolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(multiRolesAuthority.doesUserHaveRole(user, role));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertTrue(multiRolesAuthority.doesUserHaveRole(user, role));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(uint8 role, bytes4 functionSig) public {\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.doesRoleHaveCapability(role, functionSig));\n    }\n\n    function testSetPublicCapabilities(bytes4 functionSig) public {\n        assertFalse(multiRolesAuthority.isCapabilityPublic(functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.isCapabilityPublic(functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertFalse(multiRolesAuthority.isCapabilityPublic(functionSig));\n    }\n\n    function testSetTargetCustomAuthority(address user, Authority customAuthority) public {\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(0));\n\n        multiRolesAuthority.setTargetCustomAuthority(user, customAuthority);\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(customAuthority));\n\n        multiRolesAuthority.setTargetCustomAuthority(user, Authority(address(0)));\n        assertEq(address(multiRolesAuthority.getTargetCustomAuthority(user)), address(0));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthority(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, false);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setPublicCapability(functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallWithCustomAuthorityOverridesUserWithRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(false));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, new MockAuthority(true));\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setTargetCustomAuthority(target, Authority(address(0)));\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, true);\n        assertTrue(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setRoleCapability(role, functionSig, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n\n        multiRolesAuthority.setUserRole(user, role, false);\n        assertFalse(multiRolesAuthority.canCall(user, target, functionSig));\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/Owned.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockOwned} from \"./utils/mocks/MockOwned.sol\";\n\ncontract OwnedTest is DSTestPlus {\n    MockOwned mockOwned;\n\n    function setUp() public {\n        mockOwned = new MockOwned();\n    }\n\n    function testTransferOwnership() public {\n        testTransferOwnership(address(0xBEEF));\n    }\n\n    function testCallFunctionAsNonOwner() public {\n        testCallFunctionAsNonOwner(address(0));\n    }\n\n    function testCallFunctionAsOwner() public {\n        mockOwned.updateFlag();\n    }\n\n    function testTransferOwnership(address newOwner) public {\n        mockOwned.transferOwnership(newOwner);\n\n        assertEq(mockOwned.owner(), newOwner);\n    }\n\n    function testCallFunctionAsNonOwner(address owner) public {\n        hevm.assume(owner != address(this));\n\n        mockOwned.transferOwnership(owner);\n\n        hevm.expectRevert(\"UNAUTHORIZED\");\n        mockOwned.updateFlag();\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/ReentrancyGuard.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\";\n\ncontract RiskyContract is ReentrancyGuard {\n    uint256 public enterTimes;\n\n    function unprotectedCall() public {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function protectedCall() public nonReentrant {\n        enterTimes++;\n\n        if (enterTimes > 1) return;\n\n        this.protectedCall();\n    }\n\n    function overprotectedCall() public nonReentrant {}\n}\n\ncontract ReentrancyGuardTest is DSTestPlus {\n    RiskyContract riskyContract;\n\n    function setUp() public {\n        riskyContract = new RiskyContract();\n    }\n\n    function invariantReentrancyStatusAlways1() public {\n        assertEq(uint256(hevm.load(address(riskyContract), 0)), 1);\n    }\n\n    function testFailUnprotectedCall() public {\n        riskyContract.unprotectedCall();\n\n        assertEq(riskyContract.enterTimes(), 1);\n    }\n\n    function testProtectedCall() public {\n        try riskyContract.protectedCall() {\n            fail(\"Reentrancy Guard Failed To Stop Attacker\");\n        } catch {}\n    }\n\n    function testNoReentrancy() public {\n        riskyContract.overprotectedCall();\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/RolesAuthority.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {MockAuthority} from \"./utils/mocks/MockAuthority.sol\";\n\nimport {Authority} from \"../auth/Auth.sol\";\n\nimport {RolesAuthority} from \"../auth/authorities/RolesAuthority.sol\";\n\ncontract RolesAuthorityTest is DSTestPlus {\n    RolesAuthority rolesAuthority;\n\n    function setUp() public {\n        rolesAuthority = new RolesAuthority(address(this), Authority(address(0)));\n    }\n\n    function testSetRoles() public {\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(address(0xBEEF), 0));\n    }\n\n    function testSetRoleCapabilities() public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(0, address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetPublicCapabilities() public {\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallWithAuthorizedRole() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, true);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setRoleCapability(0, address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setUserRole(address(0xBEEF), 0, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testCanCallPublicCapability() public {\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, true);\n        assertTrue(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n\n        rolesAuthority.setPublicCapability(address(0xCAFE), 0xBEEFCAFE, false);\n        assertFalse(rolesAuthority.canCall(address(0xBEEF), address(0xCAFE), 0xBEEFCAFE));\n    }\n\n    function testSetRoles(address user, uint8 role) public {\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertTrue(rolesAuthority.doesUserHaveRole(user, role));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.doesUserHaveRole(user, role));\n    }\n\n    function testSetRoleCapabilities(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.doesRoleHaveCapability(role, target, functionSig));\n    }\n\n    function testSetPublicCapabilities(address target, bytes4 functionSig) public {\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.isCapabilityPublic(target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.isCapabilityPublic(target, functionSig));\n    }\n\n    function testCanCallWithAuthorizedRole(\n        address user,\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, true);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setRoleCapability(role, target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setUserRole(user, role, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n\n    function testCanCallPublicCapability(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public {\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, true);\n        assertTrue(rolesAuthority.canCall(user, target, functionSig));\n\n        rolesAuthority.setPublicCapability(target, functionSig, false);\n        assertFalse(rolesAuthority.canCall(user, target, functionSig));\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/SSTORE2.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SSTORE2} from \"../utils/SSTORE2.sol\";\n\ncontract SSTORE2Test is DSTestPlus {\n    function testWriteRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        address pointer = SSTORE2.write(testBytes);\n\n        assertBytesEq(SSTORE2.read(pointer), testBytes);\n    }\n\n    function testWriteReadFullStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 0), hex\"11223344\");\n    }\n\n    function testWriteReadCustomStartBound() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1), hex\"223344\");\n    }\n\n    function testWriteReadFullBoundedRead() public {\n        bytes memory testBytes = abi.encode(\"this is a test\");\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), 0, testBytes.length), testBytes);\n    }\n\n    function testWriteReadCustomBounds() public {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(hex\"11223344\"), 1, 3), hex\"2233\");\n    }\n\n    function testWriteReadEmptyBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 3, 3);\n    }\n\n    function testFailReadInvalidPointer() public view {\n        SSTORE2.read(DEAD_ADDRESS);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound() public view {\n        SSTORE2.read(DEAD_ADDRESS, 1);\n    }\n\n    function testFailReadInvalidPointerCustomBounds() public view {\n        SSTORE2.read(DEAD_ADDRESS, 2, 4);\n    }\n\n    function testFailWriteReadOutOfStartBound() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000);\n    }\n\n    function testFailWriteReadEmptyOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 42000, 42000);\n    }\n\n    function testFailWriteReadOutOfBounds() public {\n        SSTORE2.read(SSTORE2.write(hex\"11223344\"), 41000, 42000);\n    }\n\n    function testWriteRead(bytes calldata testBytes, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes)), testBytes);\n    }\n\n    function testWriteReadCustomStartBound(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), startIndex), bytes(testBytes[startIndex:]));\n    }\n\n    function testWriteReadCustomBounds(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (testBytes.length == 0) return;\n\n        endIndex = bound(endIndex, 0, testBytes.length);\n        startIndex = bound(startIndex, 0, testBytes.length);\n\n        if (startIndex > endIndex) return;\n\n        assertBytesEq(\n            SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex),\n            bytes(testBytes[startIndex:endIndex])\n        );\n    }\n\n    function testFailReadInvalidPointer(address pointer, bytes calldata brutalizeWith)\n        public\n        view\n        brutalizeMemory(brutalizeWith)\n    {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer);\n    }\n\n    function testFailReadInvalidPointerCustomStartBound(\n        address pointer,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex);\n    }\n\n    function testFailReadInvalidPointerCustomBounds(\n        address pointer,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public view brutalizeMemory(brutalizeWith) {\n        if (pointer.code.length > 0) revert();\n\n        SSTORE2.read(pointer, startIndex, endIndex);\n    }\n\n    function testFailWriteReadCustomStartBoundOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        startIndex = bound(startIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex);\n    }\n\n    function testFailWriteReadCustomBoundsOutOfRange(\n        bytes calldata testBytes,\n        uint256 startIndex,\n        uint256 endIndex,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        endIndex = bound(endIndex, testBytes.length + 1, type(uint256).max);\n\n        SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/SafeCastLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {SafeCastLib} from \"../utils/SafeCastLib.sol\";\n\ncontract SafeCastLibTest is DSTestPlus {\n    function testSafeCastTo248() public {\n        assertEq(SafeCastLib.safeCastTo248(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo248(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo240() public {\n        assertEq(SafeCastLib.safeCastTo240(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo240(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo232() public {\n        assertEq(SafeCastLib.safeCastTo232(2.5e45), 2.5e45);\n        assertEq(SafeCastLib.safeCastTo232(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo224() public {\n        assertEq(SafeCastLib.safeCastTo224(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo224(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo216() public {\n        assertEq(SafeCastLib.safeCastTo216(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo216(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo208() public {\n        assertEq(SafeCastLib.safeCastTo208(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo208(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo200() public {\n        assertEq(SafeCastLib.safeCastTo200(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo200(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo192() public {\n        assertEq(SafeCastLib.safeCastTo192(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo192(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo184() public {\n        assertEq(SafeCastLib.safeCastTo184(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo184(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo176() public {\n        assertEq(SafeCastLib.safeCastTo176(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo176(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo168() public {\n        assertEq(SafeCastLib.safeCastTo168(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo168(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo160() public {\n        assertEq(SafeCastLib.safeCastTo160(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo160(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo152() public {\n        assertEq(SafeCastLib.safeCastTo152(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo152(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo144() public {\n        assertEq(SafeCastLib.safeCastTo144(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo144(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo136() public {\n        assertEq(SafeCastLib.safeCastTo136(2.5e36), 2.5e36);\n        assertEq(SafeCastLib.safeCastTo136(2.5e27), 2.5e27);\n    }\n\n    function testSafeCastTo128() public {\n        assertEq(SafeCastLib.safeCastTo128(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo128(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo120() public {\n        assertEq(SafeCastLib.safeCastTo120(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo120(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo112() public {\n        assertEq(SafeCastLib.safeCastTo112(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo112(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo104() public {\n        assertEq(SafeCastLib.safeCastTo104(2.5e27), 2.5e27);\n        assertEq(SafeCastLib.safeCastTo104(2.5e18), 2.5e18);\n    }\n\n    function testSafeCastTo96() public {\n        assertEq(SafeCastLib.safeCastTo96(2.5e18), 2.5e18);\n        assertEq(SafeCastLib.safeCastTo96(2.5e17), 2.5e17);\n    }\n\n    function testSafeCastTo64() public {\n        assertEq(SafeCastLib.safeCastTo64(2.5e18), 2.5e18);\n        assertEq(SafeCastLib.safeCastTo64(2.5e17), 2.5e17);\n    }\n\n    function testSafeCastTo56() public {\n        assertEq(SafeCastLib.safeCastTo56(2.5e16), 2.5e16);\n        assertEq(SafeCastLib.safeCastTo56(2.5e15), 2.5e15);\n    }\n\n    function testSafeCastTo48() public {\n        assertEq(SafeCastLib.safeCastTo48(2.5e12), 2.5e12);\n        assertEq(SafeCastLib.safeCastTo48(2.5e11), 2.5e11);\n    }\n\n    function testSafeCastTo40() public {\n        assertEq(SafeCastLib.safeCastTo40(2.5e10), 2.5e10);\n        assertEq(SafeCastLib.safeCastTo40(2.5e9), 2.5e9);\n    }\n\n    function testSafeCastTo32() public {\n        assertEq(SafeCastLib.safeCastTo32(2.5e8), 2.5e8);\n        assertEq(SafeCastLib.safeCastTo32(2.5e7), 2.5e7);\n    }\n\n    function testSafeCastTo24() public {\n        assertEq(SafeCastLib.safeCastTo24(2.5e4), 2.5e4);\n        assertEq(SafeCastLib.safeCastTo24(2.5e3), 2.5e3);\n    }\n\n    function testSafeCastTo16() public {\n        assertEq(SafeCastLib.safeCastTo16(2.5e3), 2.5e3);\n        assertEq(SafeCastLib.safeCastTo16(2.5e2), 2.5e2);\n    }\n\n    function testSafeCastTo8() public {\n        assertEq(SafeCastLib.safeCastTo8(100), 100);\n        assertEq(SafeCastLib.safeCastTo8(250), 250);\n    }\n\n    function testFailSafeCastTo248() public pure {\n        SafeCastLib.safeCastTo248(type(uint248).max + 1);\n    }\n\n    function testFailSafeCastTo240() public pure {\n        SafeCastLib.safeCastTo240(type(uint240).max + 1);\n    }\n\n    function testFailSafeCastTo232() public pure {\n        SafeCastLib.safeCastTo232(type(uint232).max + 1);\n    }\n\n    function testFailSafeCastTo224() public pure {\n        SafeCastLib.safeCastTo224(type(uint224).max + 1);\n    }\n\n    function testFailSafeCastTo216() public pure {\n        SafeCastLib.safeCastTo216(type(uint216).max + 1);\n    }\n\n    function testFailSafeCastTo208() public pure {\n        SafeCastLib.safeCastTo208(type(uint208).max + 1);\n    }\n\n    function testFailSafeCastTo200() public pure {\n        SafeCastLib.safeCastTo200(type(uint200).max + 1);\n    }\n\n    function testFailSafeCastTo192() public pure {\n        SafeCastLib.safeCastTo192(type(uint192).max + 1);\n    }\n\n    function testFailSafeCastTo184() public pure {\n        SafeCastLib.safeCastTo184(type(uint184).max + 1);\n    }\n\n    function testFailSafeCastTo176() public pure {\n        SafeCastLib.safeCastTo176(type(uint176).max + 1);\n    }\n\n    function testFailSafeCastTo168() public pure {\n        SafeCastLib.safeCastTo168(type(uint168).max + 1);\n    }\n\n    function testFailSafeCastTo160() public pure {\n        SafeCastLib.safeCastTo160(type(uint160).max + 1);\n    }\n\n    function testFailSafeCastTo152() public pure {\n        SafeCastLib.safeCastTo152(type(uint152).max + 1);\n    }\n\n    function testFailSafeCastTo144() public pure {\n        SafeCastLib.safeCastTo144(type(uint144).max + 1);\n    }\n\n    function testFailSafeCastTo136() public pure {\n        SafeCastLib.safeCastTo136(type(uint136).max + 1);\n    }\n\n    function testFailSafeCastTo128() public pure {\n        SafeCastLib.safeCastTo128(type(uint128).max + 1);\n    }\n\n    function testFailSafeCastTo120() public pure {\n        SafeCastLib.safeCastTo120(type(uint120).max + 1);\n    }\n\n    function testFailSafeCastTo112() public pure {\n        SafeCastLib.safeCastTo112(type(uint112).max + 1);\n    }\n\n    function testFailSafeCastTo104() public pure {\n        SafeCastLib.safeCastTo104(type(uint104).max + 1);\n    }\n\n    function testFailSafeCastTo96() public pure {\n        SafeCastLib.safeCastTo96(type(uint96).max + 1);\n    }\n\n    function testFailSafeCastTo88() public pure {\n        SafeCastLib.safeCastTo88(type(uint88).max + 1);\n    }\n\n    function testFailSafeCastTo80() public pure {\n        SafeCastLib.safeCastTo80(type(uint80).max + 1);\n    }\n\n    function testFailSafeCastTo72() public pure {\n        SafeCastLib.safeCastTo72(type(uint72).max + 1);\n    }\n\n    function testFailSafeCastTo64() public pure {\n        SafeCastLib.safeCastTo64(type(uint64).max + 1);\n    }\n\n    function testFailSafeCastTo56() public pure {\n        SafeCastLib.safeCastTo56(type(uint56).max + 1);\n    }\n\n    function testFailSafeCastTo48() public pure {\n        SafeCastLib.safeCastTo48(type(uint48).max + 1);\n    }\n\n    function testFailSafeCastTo40() public pure {\n        SafeCastLib.safeCastTo40(type(uint40).max + 1);\n    }\n\n    function testFailSafeCastTo32() public pure {\n        SafeCastLib.safeCastTo32(type(uint32).max + 1);\n    }\n\n    function testFailSafeCastTo24() public pure {\n        SafeCastLib.safeCastTo24(type(uint24).max + 1);\n    }\n\n    function testFailSafeCastTo16() public pure {\n        SafeCastLib.safeCastTo16(type(uint16).max + 1);\n    }\n\n    function testFailSafeCastTo8() public pure {\n        SafeCastLib.safeCastTo8(type(uint8).max + 1);\n    }\n\n    function testSafeCastTo248(uint256 x) public {\n        x = bound(x, 0, type(uint248).max);\n\n        assertEq(SafeCastLib.safeCastTo248(x), x);\n    }\n\n    function testSafeCastTo240(uint256 x) public {\n        x = bound(x, 0, type(uint240).max);\n\n        assertEq(SafeCastLib.safeCastTo240(x), x);\n    }\n\n    function testSafeCastTo232(uint256 x) public {\n        x = bound(x, 0, type(uint232).max);\n\n        assertEq(SafeCastLib.safeCastTo232(x), x);\n    }\n\n    function testSafeCastTo224(uint256 x) public {\n        x = bound(x, 0, type(uint224).max);\n\n        assertEq(SafeCastLib.safeCastTo224(x), x);\n    }\n\n    function testSafeCastTo216(uint256 x) public {\n        x = bound(x, 0, type(uint216).max);\n\n        assertEq(SafeCastLib.safeCastTo216(x), x);\n    }\n\n    function testSafeCastTo208(uint256 x) public {\n        x = bound(x, 0, type(uint208).max);\n\n        assertEq(SafeCastLib.safeCastTo208(x), x);\n    }\n\n    function testSafeCastTo200(uint256 x) public {\n        x = bound(x, 0, type(uint200).max);\n\n        assertEq(SafeCastLib.safeCastTo200(x), x);\n    }\n\n    function testSafeCastTo192(uint256 x) public {\n        x = bound(x, 0, type(uint192).max);\n\n        assertEq(SafeCastLib.safeCastTo192(x), x);\n    }\n\n    function testSafeCastTo184(uint256 x) public {\n        x = bound(x, 0, type(uint184).max);\n\n        assertEq(SafeCastLib.safeCastTo184(x), x);\n    }\n\n    function testSafeCastTo176(uint256 x) public {\n        x = bound(x, 0, type(uint176).max);\n\n        assertEq(SafeCastLib.safeCastTo176(x), x);\n    }\n\n    function testSafeCastTo168(uint256 x) public {\n        x = bound(x, 0, type(uint168).max);\n\n        assertEq(SafeCastLib.safeCastTo168(x), x);\n    }\n\n    function testSafeCastTo160(uint256 x) public {\n        x = bound(x, 0, type(uint160).max);\n\n        assertEq(SafeCastLib.safeCastTo160(x), x);\n    }\n\n    function testSafeCastTo152(uint256 x) public {\n        x = bound(x, 0, type(uint152).max);\n\n        assertEq(SafeCastLib.safeCastTo152(x), x);\n    }\n\n    function testSafeCastTo144(uint256 x) public {\n        x = bound(x, 0, type(uint144).max);\n\n        assertEq(SafeCastLib.safeCastTo144(x), x);\n    }\n\n    function testSafeCastTo136(uint256 x) public {\n        x = bound(x, 0, type(uint136).max);\n\n        assertEq(SafeCastLib.safeCastTo136(x), x);\n    }\n\n    function testSafeCastTo128(uint256 x) public {\n        x = bound(x, 0, type(uint128).max);\n\n        assertEq(SafeCastLib.safeCastTo128(x), x);\n    }\n\n    function testSafeCastTo120(uint256 x) public {\n        x = bound(x, 0, type(uint120).max);\n\n        assertEq(SafeCastLib.safeCastTo120(x), x);\n    }\n\n    function testSafeCastTo112(uint256 x) public {\n        x = bound(x, 0, type(uint112).max);\n\n        assertEq(SafeCastLib.safeCastTo112(x), x);\n    }\n\n    function testSafeCastTo104(uint256 x) public {\n        x = bound(x, 0, type(uint104).max);\n\n        assertEq(SafeCastLib.safeCastTo104(x), x);\n    }\n\n    function testSafeCastTo96(uint256 x) public {\n        x = bound(x, 0, type(uint96).max);\n\n        assertEq(SafeCastLib.safeCastTo96(x), x);\n    }\n\n    function testSafeCastTo88(uint256 x) public {\n        x = bound(x, 0, type(uint88).max);\n\n        assertEq(SafeCastLib.safeCastTo88(x), x);\n    }\n\n    function testSafeCastTo80(uint256 x) public {\n        x = bound(x, 0, type(uint80).max);\n\n        assertEq(SafeCastLib.safeCastTo80(x), x);\n    }\n\n    function testSafeCastTo72(uint256 x) public {\n        x = bound(x, 0, type(uint72).max);\n\n        assertEq(SafeCastLib.safeCastTo72(x), x);\n    }\n\n    function testSafeCastTo64(uint256 x) public {\n        x = bound(x, 0, type(uint64).max);\n\n        assertEq(SafeCastLib.safeCastTo64(x), x);\n    }\n\n    function testSafeCastTo56(uint256 x) public {\n        x = bound(x, 0, type(uint56).max);\n\n        assertEq(SafeCastLib.safeCastTo56(x), x);\n    }\n\n    function testSafeCastTo48(uint256 x) public {\n        x = bound(x, 0, type(uint48).max);\n\n        assertEq(SafeCastLib.safeCastTo48(x), x);\n    }\n\n    function testSafeCastTo40(uint256 x) public {\n        x = bound(x, 0, type(uint40).max);\n\n        assertEq(SafeCastLib.safeCastTo40(x), x);\n    }\n\n    function testSafeCastTo32(uint256 x) public {\n        x = bound(x, 0, type(uint32).max);\n\n        assertEq(SafeCastLib.safeCastTo32(x), x);\n    }\n\n    function testSafeCastTo24(uint256 x) public {\n        x = bound(x, 0, type(uint24).max);\n\n        assertEq(SafeCastLib.safeCastTo24(x), x);\n    }\n\n    function testSafeCastTo16(uint256 x) public {\n        x = bound(x, 0, type(uint16).max);\n\n        assertEq(SafeCastLib.safeCastTo16(x), x);\n    }\n\n    function testSafeCastTo8(uint256 x) public {\n        x = bound(x, 0, type(uint8).max);\n\n        assertEq(SafeCastLib.safeCastTo8(x), x);\n    }\n\n    function testFailSafeCastTo248(uint256 x) public {\n        x = bound(x, type(uint248).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo248(x);\n    }\n\n    function testFailSafeCastTo240(uint256 x) public {\n        x = bound(x, type(uint240).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo240(x);\n    }\n\n    function testFailSafeCastTo232(uint256 x) public {\n        x = bound(x, type(uint232).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo232(x);\n    }\n\n    function testFailSafeCastTo224(uint256 x) public {\n        x = bound(x, type(uint224).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo224(x);\n    }\n\n    function testFailSafeCastTo216(uint256 x) public {\n        x = bound(x, type(uint216).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo216(x);\n    }\n\n    function testFailSafeCastTo208(uint256 x) public {\n        x = bound(x, type(uint208).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo208(x);\n    }\n\n    function testFailSafeCastTo200(uint256 x) public {\n        x = bound(x, type(uint200).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo200(x);\n    }\n\n    function testFailSafeCastTo192(uint256 x) public {\n        x = bound(x, type(uint192).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo192(x);\n    }\n\n    function testFailSafeCastTo184(uint256 x) public {\n        x = bound(x, type(uint184).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo184(x);\n    }\n\n    function testFailSafeCastTo176(uint256 x) public {\n        x = bound(x, type(uint176).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo176(x);\n    }\n\n    function testFailSafeCastTo168(uint256 x) public {\n        x = bound(x, type(uint168).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo168(x);\n    }\n\n    function testFailSafeCastTo160(uint256 x) public {\n        x = bound(x, type(uint160).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo160(x);\n    }\n\n    function testFailSafeCastTo152(uint256 x) public {\n        x = bound(x, type(uint152).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo152(x);\n    }\n\n    function testFailSafeCastTo144(uint256 x) public {\n        x = bound(x, type(uint144).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo144(x);\n    }\n\n    function testFailSafeCastTo136(uint256 x) public {\n        x = bound(x, type(uint136).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo136(x);\n    }\n\n    function testFailSafeCastTo128(uint256 x) public {\n        x = bound(x, type(uint128).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo128(x);\n    }\n\n    function testFailSafeCastTo120(uint256 x) public {\n        x = bound(x, type(uint120).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo120(x);\n    }\n\n    function testFailSafeCastTo112(uint256 x) public {\n        x = bound(x, type(uint112).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo112(x);\n    }\n\n    function testFailSafeCastTo104(uint256 x) public {\n        x = bound(x, type(uint104).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo104(x);\n    }\n\n    function testFailSafeCastTo96(uint256 x) public {\n        x = bound(x, type(uint96).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo96(x);\n    }\n\n    function testFailSafeCastTo88(uint256 x) public {\n        x = bound(x, type(uint88).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo88(x);\n    }\n\n    function testFailSafeCastTo80(uint256 x) public {\n        x = bound(x, type(uint80).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo80(x);\n    }\n\n    function testFailSafeCastTo72(uint256 x) public {\n        x = bound(x, type(uint72).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo72(x);\n    }\n\n    function testFailSafeCastTo64(uint256 x) public {\n        x = bound(x, type(uint64).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo64(x);\n    }\n\n    function testFailSafeCastTo56(uint256 x) public {\n        x = bound(x, type(uint56).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo56(x);\n    }\n\n    function testFailSafeCastTo48(uint256 x) public {\n        x = bound(x, type(uint48).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo48(x);\n    }\n\n    function testFailSafeCastTo40(uint256 x) public {\n        x = bound(x, type(uint40).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo40(x);\n    }\n\n    function testFailSafeCastTo32(uint256 x) public {\n        x = bound(x, type(uint32).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo32(x);\n    }\n\n    function testFailSafeCastTo24(uint256 x) public {\n        x = bound(x, type(uint24).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo24(x);\n    }\n\n    function testFailSafeCastTo16(uint256 x) public {\n        x = bound(x, type(uint16).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo16(x);\n    }\n\n    function testFailSafeCastTo8(uint256 x) public {\n        x = bound(x, type(uint8).max + 1, type(uint256).max);\n\n        SafeCastLib.safeCastTo8(x);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/SafeTransferLib.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\nimport {RevertingToken} from \"./utils/weird-tokens/RevertingToken.sol\";\nimport {ReturnsTwoToken} from \"./utils/weird-tokens/ReturnsTwoToken.sol\";\nimport {ReturnsFalseToken} from \"./utils/weird-tokens/ReturnsFalseToken.sol\";\nimport {MissingReturnToken} from \"./utils/weird-tokens/MissingReturnToken.sol\";\nimport {ReturnsTooMuchToken} from \"./utils/weird-tokens/ReturnsTooMuchToken.sol\";\nimport {ReturnsGarbageToken} from \"./utils/weird-tokens/ReturnsGarbageToken.sol\";\nimport {ReturnsTooLittleToken} from \"./utils/weird-tokens/ReturnsTooLittleToken.sol\";\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\ncontract SafeTransferLibTest is DSTestPlus {\n    RevertingToken reverting;\n    ReturnsTwoToken returnsTwo;\n    ReturnsFalseToken returnsFalse;\n    MissingReturnToken missingReturn;\n    ReturnsTooMuchToken returnsTooMuch;\n    ReturnsGarbageToken returnsGarbage;\n    ReturnsTooLittleToken returnsTooLittle;\n\n    MockERC20 erc20;\n\n    function setUp() public {\n        reverting = new RevertingToken();\n        returnsTwo = new ReturnsTwoToken();\n        returnsFalse = new ReturnsFalseToken();\n        missingReturn = new MissingReturnToken();\n        returnsTooMuch = new ReturnsTooMuchToken();\n        returnsGarbage = new ReturnsGarbageToken();\n        returnsTooLittle = new ReturnsTooLittleToken();\n\n        erc20 = new MockERC20(\"StandardToken\", \"ST\", 18);\n        erc20.mint(address(this), type(uint256).max);\n    }\n\n    function testTransferWithMissingReturn() public {\n        verifySafeTransfer(address(missingReturn), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithStandardERC20() public {\n        verifySafeTransfer(address(erc20), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithReturnsTooMuch() public {\n        verifySafeTransfer(address(returnsTooMuch), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithNonContract() public {\n        SafeTransferLib.safeTransfer(ERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithMissingReturn() public {\n        verifySafeTransferFrom(address(missingReturn), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithStandardERC20() public {\n        verifySafeTransferFrom(address(erc20), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithReturnsTooMuch() public {\n        verifySafeTransferFrom(address(returnsTooMuch), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromWithNonContract() public {\n        SafeTransferLib.safeTransferFrom(ERC20(address(0xBADBEEF)), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithMissingReturn() public {\n        verifySafeApprove(address(missingReturn), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithStandardERC20() public {\n        verifySafeApprove(address(erc20), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithReturnsTooMuch() public {\n        verifySafeApprove(address(returnsTooMuch), address(0xBEEF), 1e18);\n    }\n\n    function testApproveWithNonContract() public {\n        SafeTransferLib.safeApprove(ERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);\n    }\n\n    function testTransferETH() public {\n        SafeTransferLib.safeTransferETH(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReturnsFalse() public {\n        verifySafeTransfer(address(returnsFalse), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReverting() public {\n        verifySafeTransfer(address(reverting), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferWithReturnsTooLittle() public {\n        verifySafeTransfer(address(returnsTooLittle), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReturnsFalse() public {\n        verifySafeTransferFrom(address(returnsFalse), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReverting() public {\n        verifySafeTransferFrom(address(reverting), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromWithReturnsTooLittle() public {\n        verifySafeTransferFrom(address(returnsTooLittle), address(0xFEED), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReturnsFalse() public {\n        verifySafeApprove(address(returnsFalse), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReverting() public {\n        verifySafeApprove(address(reverting), address(0xBEEF), 1e18);\n    }\n\n    function testFailApproveWithReturnsTooLittle() public {\n        verifySafeApprove(address(returnsTooLittle), address(0xBEEF), 1e18);\n    }\n\n    function testTransferWithMissingReturn(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(missingReturn), to, amount);\n    }\n\n    function testTransferWithStandardERC20(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(erc20), to, amount);\n    }\n\n    function testTransferWithReturnsTooMuch(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTooMuch), to, amount);\n    }\n\n    function testTransferWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransfer(address(returnsGarbage), to, amount);\n    }\n\n    function testTransferWithNonContract(\n        address nonContract,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeTransfer(ERC20(nonContract), to, amount);\n    }\n\n    function testFailTransferETHToContractWithoutFallback() public {\n        SafeTransferLib.safeTransferETH(address(this), 1e18);\n    }\n\n    function testTransferFromWithMissingReturn(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(missingReturn), from, to, amount);\n    }\n\n    function testTransferFromWithStandardERC20(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(erc20), from, to, amount);\n    }\n\n    function testTransferFromWithReturnsTooMuch(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTooMuch), from, to, amount);\n    }\n\n    function testTransferFromWithGarbage(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransferFrom(address(returnsGarbage), from, to, amount);\n    }\n\n    function testTransferFromWithNonContract(\n        address nonContract,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeTransferFrom(ERC20(nonContract), from, to, amount);\n    }\n\n    function testApproveWithMissingReturn(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(missingReturn), to, amount);\n    }\n\n    function testApproveWithStandardERC20(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(erc20), to, amount);\n    }\n\n    function testApproveWithReturnsTooMuch(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTooMuch), to, amount);\n    }\n\n    function testApproveWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (\n            (garbage.length < 32 ||\n                (garbage[0] != 0 ||\n                    garbage[1] != 0 ||\n                    garbage[2] != 0 ||\n                    garbage[3] != 0 ||\n                    garbage[4] != 0 ||\n                    garbage[5] != 0 ||\n                    garbage[6] != 0 ||\n                    garbage[7] != 0 ||\n                    garbage[8] != 0 ||\n                    garbage[9] != 0 ||\n                    garbage[10] != 0 ||\n                    garbage[11] != 0 ||\n                    garbage[12] != 0 ||\n                    garbage[13] != 0 ||\n                    garbage[14] != 0 ||\n                    garbage[15] != 0 ||\n                    garbage[16] != 0 ||\n                    garbage[17] != 0 ||\n                    garbage[18] != 0 ||\n                    garbage[19] != 0 ||\n                    garbage[20] != 0 ||\n                    garbage[21] != 0 ||\n                    garbage[22] != 0 ||\n                    garbage[23] != 0 ||\n                    garbage[24] != 0 ||\n                    garbage[25] != 0 ||\n                    garbage[26] != 0 ||\n                    garbage[27] != 0 ||\n                    garbage[28] != 0 ||\n                    garbage[29] != 0 ||\n                    garbage[30] != 0 ||\n                    garbage[31] != bytes1(0x01))) && garbage.length != 0\n        ) return;\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeApprove(address(returnsGarbage), to, amount);\n    }\n\n    function testApproveWithNonContract(\n        address nonContract,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        if (uint256(uint160(nonContract)) <= 18 || nonContract.code.length > 0) return;\n\n        SafeTransferLib.safeApprove(ERC20(nonContract), to, amount);\n    }\n\n    function testTransferETH(\n        address recipient,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        // Transferring to msg.sender can fail because it's possible to overflow their ETH balance as it begins non-zero.\n        if (recipient.code.length > 0 || uint256(uint160(recipient)) <= 18 || recipient == msg.sender) return;\n\n        amount = bound(amount, 0, address(this).balance);\n\n        SafeTransferLib.safeTransferETH(recipient, amount);\n    }\n\n    function testFailTransferWithReturnsFalse(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsFalse), to, amount);\n    }\n\n    function testFailTransferWithReverting(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(reverting), to, amount);\n    }\n\n    function testFailTransferWithReturnsTooLittle(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTooLittle), to, amount);\n    }\n\n    function testFailTransferWithReturnsTwo(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransfer(address(returnsTwo), to, amount);\n    }\n\n    function testFailTransferWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransfer(address(returnsGarbage), to, amount);\n    }\n\n    function testFailTransferFromWithReturnsFalse(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsFalse), from, to, amount);\n    }\n\n    function testFailTransferFromWithReverting(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(reverting), from, to, amount);\n    }\n\n    function testFailTransferFromWithReturnsTooLittle(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTooLittle), from, to, amount);\n    }\n\n    function testFailTransferFromWithReturnsTwo(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeTransferFrom(address(returnsTwo), from, to, amount);\n    }\n\n    function testFailTransferFromWithGarbage(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeTransferFrom(address(returnsGarbage), from, to, amount);\n    }\n\n    function testFailApproveWithReturnsFalse(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsFalse), to, amount);\n    }\n\n    function testFailApproveWithReverting(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(reverting), to, amount);\n    }\n\n    function testFailApproveWithReturnsTooLittle(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTooLittle), to, amount);\n    }\n\n    function testFailApproveWithReturnsTwo(\n        address to,\n        uint256 amount,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        verifySafeApprove(address(returnsTwo), to, amount);\n    }\n\n    function testFailApproveWithGarbage(\n        address to,\n        uint256 amount,\n        bytes memory garbage,\n        bytes calldata brutalizeWith\n    ) public brutalizeMemory(brutalizeWith) {\n        require(garbage.length != 0 && (garbage.length < 32 || garbage[31] != bytes1(0x01)));\n\n        returnsGarbage.setGarbage(garbage);\n\n        verifySafeApprove(address(returnsGarbage), to, amount);\n    }\n\n    function testFailTransferETHToContractWithoutFallback(uint256 amount, bytes calldata brutalizeWith)\n        public\n        brutalizeMemory(brutalizeWith)\n    {\n        SafeTransferLib.safeTransferETH(address(this), amount);\n    }\n\n    function verifySafeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 preBal = ERC20(token).balanceOf(to);\n        SafeTransferLib.safeTransfer(ERC20(address(token)), to, amount);\n        uint256 postBal = ERC20(token).balanceOf(to);\n\n        if (to == address(this)) {\n            assertEq(preBal, postBal);\n        } else {\n            assertEq(postBal - preBal, amount);\n        }\n    }\n\n    function verifySafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        forceApprove(token, from, address(this), amount);\n\n        // We cast to MissingReturnToken here because it won't check\n        // that there was return data, which accommodates all tokens.\n        MissingReturnToken(token).transfer(from, amount);\n\n        uint256 preBal = ERC20(token).balanceOf(to);\n        SafeTransferLib.safeTransferFrom(ERC20(token), from, to, amount);\n        uint256 postBal = ERC20(token).balanceOf(to);\n\n        if (from == to) {\n            assertEq(preBal, postBal);\n        } else {\n            assertEq(postBal - preBal, amount);\n        }\n    }\n\n    function verifySafeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        SafeTransferLib.safeApprove(ERC20(address(token)), to, amount);\n\n        assertEq(ERC20(token).allowance(address(this), to), amount);\n    }\n\n    function forceApprove(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 slot = token == address(erc20) ? 4 : 2; // Standard ERC20 name and symbol aren't constant.\n\n        hevm.store(\n            token,\n            keccak256(abi.encode(to, keccak256(abi.encode(from, uint256(slot))))),\n            bytes32(uint256(amount))\n        );\n\n        assertEq(ERC20(token).allowance(from, to), amount, \"wrong allowance\");\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/SignedWadMath.t.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\n\nimport {wadMul, wadDiv} from \"../utils/SignedWadMath.sol\";\n\ncontract SignedWadMathTest is DSTestPlus {\n    function testWadMul(\n        uint256 x,\n        uint256 y,\n        bool negX,\n        bool negY\n    ) public {\n        x = bound(x, 0, 99999999999999e18);\n        y = bound(x, 0, 99999999999999e18);\n\n        int256 xPrime = negX ? -int256(x) : int256(x);\n        int256 yPrime = negY ? -int256(y) : int256(y);\n\n        assertEq(wadMul(xPrime, yPrime), (xPrime * yPrime) / 1e18);\n    }\n\n    function testFailWadMulEdgeCase() public pure {\n        int256 x = -1;\n        int256 y = type(int256).min;\n\n        wadMul(x, y);\n    }\n\n    function testFailWadMulEdgeCase2() public pure {\n        int256 x = type(int256).min;\n        int256 y = -1;\n\n        wadMul(x, y);\n    }\n\n    function testFailWadMulOverflow(int256 x, int256 y) public pure {\n        // Ignore cases where x * y does not overflow.\n        unchecked {\n            if ((x * y) / x == y) revert();\n        }\n\n        wadMul(x, y);\n    }\n\n    function testWadDiv(\n        uint256 x,\n        uint256 y,\n        bool negX,\n        bool negY\n    ) public {\n        x = bound(x, 0, 99999999e18);\n        y = bound(x, 1, 99999999e18);\n\n        int256 xPrime = negX ? -int256(x) : int256(x);\n        int256 yPrime = negY ? -int256(y) : int256(y);\n\n        assertEq(wadDiv(xPrime, yPrime), (xPrime * 1e18) / yPrime);\n    }\n\n    function testFailWadDivOverflow(int256 x, int256 y) public pure {\n        // Ignore cases where x * WAD does not overflow or y is 0.\n        unchecked {\n            if (y == 0 || (x * 1e18) / 1e18 == x) revert();\n        }\n\n        wadDiv(x, y);\n    }\n\n    function testFailWadDivZeroDenominator(int256 x) public pure {\n        wadDiv(x, 0);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/WETH.t.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\nimport {WETH} from \"../tokens/WETH.sol\";\n\ncontract WETHTest is DSTestPlus {\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n    }\n\n    function testFallbackDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), 1 ether);\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testDeposit() public {\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: 1 ether}();\n\n        assertEq(weth.balanceOf(address(this)), 1 ether);\n        assertEq(weth.totalSupply(), 1 ether);\n    }\n\n    function testWithdraw() public {\n        uint256 startingBalance = address(this).balance;\n\n        weth.deposit{value: 1 ether}();\n\n        weth.withdraw(1 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, startingBalance);\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n    }\n\n    function testPartialWithdraw() public {\n        weth.deposit{value: 1 ether}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(0.5 ether);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);\n        assertEq(weth.balanceOf(address(this)), 0.5 ether);\n        assertEq(weth.totalSupply(), 0.5 ether);\n    }\n\n    function testFallbackDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testDeposit(uint256 amount) public {\n        amount = bound(amount, 0, address(this).balance);\n\n        assertEq(weth.balanceOf(address(this)), 0);\n        assertEq(weth.totalSupply(), 0);\n\n        weth.deposit{value: amount}();\n\n        assertEq(weth.balanceOf(address(this)), amount);\n        assertEq(weth.totalSupply(), amount);\n    }\n\n    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {\n        depositAmount = bound(depositAmount, 0, address(this).balance);\n        withdrawAmount = bound(withdrawAmount, 0, depositAmount);\n\n        weth.deposit{value: depositAmount}();\n\n        uint256 balanceBeforeWithdraw = address(this).balance;\n\n        weth.withdraw(withdrawAmount);\n\n        uint256 balanceAfterWithdraw = address(this).balance;\n\n        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);\n        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);\n        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);\n    }\n\n    receive() external payable {}\n}\n\ncontract WETHInvariants is DSTestPlus, DSInvariantTest {\n    WETHTester wethTester;\n    WETH weth;\n\n    function setUp() public {\n        weth = new WETH();\n        wethTester = new WETHTester{value: address(this).balance}(weth);\n\n        addTargetContract(address(wethTester));\n    }\n\n    function invariantTotalSupplyEqualsBalance() public {\n        assertEq(address(weth).balance, weth.totalSupply());\n    }\n}\n\ncontract WETHTester {\n    WETH weth;\n\n    constructor(WETH _weth) payable {\n        weth = _weth;\n    }\n\n    function deposit(uint256 amount) public {\n        weth.deposit{value: amount}();\n    }\n\n    function fallbackDeposit(uint256 amount) public {\n        SafeTransferLib.safeTransferETH(address(weth), amount);\n    }\n\n    function withdraw(uint256 amount) public {\n        weth.withdraw(amount);\n    }\n\n    receive() external payable {}\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/DSInvariantTest.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract DSInvariantTest {\n    address[] private targets;\n\n    function targetContracts() public view virtual returns (address[] memory) {\n        require(targets.length > 0, \"NO_TARGET_CONTRACTS\");\n\n        return targets;\n    }\n\n    function addTargetContract(address newTargetContract) internal virtual {\n        targets.push(newTargetContract);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/DSTestPlus.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\n\nimport {Hevm} from \"./Hevm.sol\";\n\n/// @notice Extended testing framework for DappTools projects.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/test/utils/DSTestPlus.sol)\ncontract DSTestPlus is DSTest {\n    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);\n\n    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;\n\n    string private checkpointLabel;\n    uint256 private checkpointGasLeft = 1; // Start the slot warm.\n\n    modifier brutalizeMemory(bytes memory brutalizeWith) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Fill the 64 bytes of scratch space with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    64, // Copy enough to only fill the scratch space.\n                    0, // Store the return value in the scratch space.\n                    64 // Scratch space is only 64 bytes in size, we don't want to write further.\n                )\n            )\n\n            let size := add(mload(brutalizeWith), 32) // Add 32 to include the 32 byte length slot.\n\n            // Fill the free memory pointer's destination with the data.\n            pop(\n                staticcall(\n                    gas(), // Pass along all the gas in the call.\n                    0x04, // Call the identity precompile address.\n                    brutalizeWith, // Offset is the bytes' pointer.\n                    size, // We want to pass the length of the bytes.\n                    mload(0x40), // Store the return value at the free memory pointer.\n                    size // Since the precompile just returns its input, we reuse size.\n                )\n            )\n        }\n\n        _;\n    }\n\n    function startMeasuringGas(string memory label) internal virtual {\n        checkpointLabel = label;\n\n        checkpointGasLeft = gasleft();\n    }\n\n    function stopMeasuringGas() internal virtual {\n        uint256 checkpointGasLeft2 = gasleft();\n\n        // Subtract 100 to account for the warm SLOAD in startMeasuringGas.\n        uint256 gasDelta = checkpointGasLeft - checkpointGasLeft2 - 100;\n\n        emit log_named_uint(string(abi.encodePacked(checkpointLabel, \" Gas\")), gasDelta);\n    }\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertUint128Eq(uint128 a, uint128 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint64Eq(uint64 a, uint64 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint96Eq(uint96 a, uint96 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertUint32Eq(uint32 a, uint32 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertBoolEq(bool a, bool b) internal virtual {\n        b ? assertTrue(a) : assertFalse(a);\n    }\n\n    function assertApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = a > b ? a - b : b - a;\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertRelApproxEq(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = ((a > b ? a - b : b - a) * 1e18) / b;\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"    Expected\", b);\n            emit log_named_uint(\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertBytesEq(bytes memory a, bytes memory b) internal virtual {\n        if (keccak256(a) != keccak256(b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertUintArrayEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        require(a.length == b.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < a.length; i++) {\n            assertEq(a[i], b[i]);\n        }\n    }\n\n    function bound(\n        uint256 x,\n        uint256 min,\n        uint256 max\n    ) internal virtual returns (uint256 result) {\n        require(max >= min, \"MAX_LESS_THAN_MIN\");\n\n        uint256 size = max - min;\n\n        if (size == 0) result = min;\n        else if (size == type(uint256).max) result = x;\n        else {\n            ++size; // Make max inclusive.\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    function min3(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (uint256) {\n        return a > b ? (b > c ? c : b) : (a > c ? c : a);\n    }\n\n    function min2(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/Hevm.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface Hevm {\n    /// @notice Sets the block timestamp.\n    function warp(uint256) external;\n\n    /// @notice Sets the block height.\n    function roll(uint256) external;\n\n    /// @notice Sets the block base fee.\n    function fee(uint256) external;\n\n    /// @notice Loads a storage slot from an address.\n    function load(address, bytes32) external returns (bytes32);\n\n    /// @notice Stores a value to an address' storage slot.\n    function store(\n        address,\n        bytes32,\n        bytes32\n    ) external;\n\n    /// @notice Signs a digest with a private key, returns v r s.\n    function sign(uint256, bytes32)\n        external\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        );\n\n    /// @notice Gets address for a given private key.\n    function addr(uint256) external returns (address);\n\n    /// @notice Performs a foreign function call via a terminal call.\n    function ffi(string[] calldata) external returns (bytes memory);\n\n    /// @notice Sets the next call's msg.sender to be the input address.\n    function prank(address) external;\n\n    /// @notice Sets all subsequent calls' msg.sender to be the input address until stopPrank is called.\n    function startPrank(address) external;\n\n    /// @notice Sets the next call's msg.sender to be the input address and the tx.origin to be the second input.\n    function prank(address, address) external;\n\n    /// @notice Sets all subsequent calls' msg.sender to be the input address and\n    /// sets tx.origin to be the second address inputted until stopPrank is called.\n    function startPrank(address, address) external;\n\n    /// @notice Resets msg.sender to its original value before a prank.\n    function stopPrank() external;\n\n    /// @notice Sets an address' balance.\n    function deal(address, uint256) external;\n\n    /// @notice Sets an address' code.\n    function etch(address, bytes calldata) external;\n\n    /// @notice Expects an error from the next call.\n    function expectRevert(bytes calldata) external;\n\n    /// @notice Expects a revert from the next call.\n    function expectRevert(bytes4) external;\n\n    /// @notice Record all storage reads and writes.\n    function record() external;\n\n    /// @notice Gets all accessed reads and write slots from a recording session, for a given address.\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n\n    /// @notice Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    /// @notice Call this function, then emit an event, then call a function. Internally after the call, we check\n    /// if logs were emitted in the expected order with the expected topics and data as specified by the booleans.\n    function expectEmit(\n        bool,\n        bool,\n        bool,\n        bool\n    ) external;\n\n    /// @notice Mocks the behavior of a contract call, setting the input and output for a function.\n    /// @notice Calldata can either be strict or a partial match, e.g. if only passed\n    /// a selector to the expected calldata, then the entire function will be mocked.\n    function mockCall(\n        address,\n        bytes calldata,\n        bytes calldata\n    ) external;\n\n    /// @notice Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// @notice Expect a call to an address with the specified calldata.\n    /// @notice Calldata can either be strict or a partial match.\n    function expectCall(address, bytes calldata) external;\n\n    /// @notice Fetches the contract bytecode from its artifact file.\n    function getCode(string calldata) external returns (bytes memory);\n\n    /// @notice Label an address in test traces.\n    function label(address addr, string calldata label) external;\n\n    /// @notice When fuzzing, generate new inputs if the input conditional is not met.\n    function assume(bool) external;\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockAuthChild.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../../../auth/Auth.sol\";\n\ncontract MockAuthChild is Auth(msg.sender, Authority(address(0))) {\n    bool public flag;\n\n    function updateFlag() public virtual requiresAuth {\n        flag = true;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockAuthority.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Authority} from \"../../../auth/Auth.sol\";\n\ncontract MockAuthority is Authority {\n    bool immutable allowCalls;\n\n    constructor(bool _allowCalls) {\n        allowCalls = _allowCalls;\n    }\n\n    function canCall(\n        address,\n        address,\n        bytes4\n    ) public view override returns (bool) {\n        return allowCalls;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockERC1155.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC1155} from \"../../../tokens/ERC1155.sol\";\n\ncontract MockERC1155 is ERC1155 {\n    function uri(uint256) public pure virtual override returns (string memory) {}\n\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        _mint(to, id, amount, data);\n    }\n\n    function batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        _batchMint(to, ids, amounts, data);\n    }\n\n    function burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) public virtual {\n        _burn(from, id, amount);\n    }\n\n    function batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) public virtual {\n        _batchBurn(from, ids, amounts);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\nimport {ERC4626} from \"../../../tokens/ERC4626.sol\";\n\ncontract MockERC4626 is ERC4626 {\n    uint256 public beforeWithdrawHookCalledCounter = 0;\n    uint256 public afterDepositHookCalledCounter = 0;\n\n    constructor(\n        ERC20 _underlying,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_underlying, _name, _symbol) {}\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    function beforeWithdraw(uint256, uint256) internal override {\n        beforeWithdrawHookCalledCounter++;\n    }\n\n    function afterDeposit(uint256, uint256) internal override {\n        afterDepositHookCalledCounter++;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockERC6909.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC6909} from \"../../../tokens/ERC6909.sol\";\n\ncontract MockERC6909 is ERC6909 {\n    function mint(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual {\n        _mint(receiver, id, amount);\n    }\n\n    function burn(\n        address sender,\n        uint256 id,\n        uint256 amount\n    ) public virtual {\n        _burn(sender, id, amount);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"../../../tokens/ERC721.sol\";\n\ncontract MockERC721 is ERC721 {\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\n\n    function tokenURI(uint256) public pure virtual override returns (string memory) {}\n\n    function mint(address to, uint256 tokenId) public virtual {\n        _mint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) public virtual {\n        _burn(tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public virtual {\n        _safeMint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual {\n        _safeMint(to, tokenId, data);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/mocks/MockOwned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Owned} from \"../../../auth/Owned.sol\";\n\ncontract MockOwned is Owned(msg.sender) {\n    bool public flag;\n\n    function updateFlag() public virtual onlyOwner {\n        flag = true;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/MissingReturnToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract MissingReturnToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"MissingReturnToken\";\n\n    string public constant symbol = \"MRT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/ReturnsFalseToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsFalseToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsFalseToken\";\n\n    string public constant symbol = \"RFT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual returns (bool) {\n        return false;\n    }\n\n    function transfer(address, uint256) public virtual returns (bool) {\n        return false;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool) {\n        return false;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/ReturnsGarbageToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsGarbageToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsGarbageToken\";\n\n    string public constant symbol = \"RGT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                              MOCK STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes garbage;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        bytes memory _garbage = garbage;\n\n        assembly {\n            return(add(_garbage, 32), mload(_garbage))\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              MOCK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setGarbage(bytes memory _garbage) public virtual {\n        garbage = _garbage;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/ReturnsTooLittleToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTooLittleToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsTooLittleToken\";\n\n    string public constant symbol = \"RTLT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n\n    function transfer(address, uint256) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        assembly {\n            mstore(0, 0x0100000000000000000000000000000000000000000000000000000000000000)\n            return(0, 8)\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/ReturnsTooMuchToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTooMuchToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsTooMuchToken\";\n\n    string public constant symbol = \"RTMT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        assembly {\n            mstore(0, 1)\n            return(0, 4096)\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/ReturnsTwoToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract ReturnsTwoToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"ReturnsFalseToken\";\n\n    string public constant symbol = \"RTT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual returns (uint256) {\n        return 2;\n    }\n\n    function transfer(address, uint256) public virtual returns (uint256) {\n        return 2;\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (uint256) {\n        return 2;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/test/utils/weird-tokens/RevertingToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\ncontract RevertingToken {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public constant name = \"RevertingToken\";\n\n    string public constant symbol = \"RT\";\n\n    uint8 public constant decimals = 18;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        totalSupply = type(uint256).max;\n        balanceOf[msg.sender] = type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address, uint256) public virtual {\n        revert();\n    }\n\n    function transfer(address, uint256) public virtual {\n        revert();\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        revert();\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/tokens/ERC1155.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/tokens/ERC4626.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/tokens/ERC6909.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC6909 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC6909.sol)\nabstract contract ERC6909 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC6909 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(address => bool)) public isOperator;\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC6909 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        balanceOf[msg.sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, msg.sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (msg.sender != sender && !isOperator[sender][msg.sender]) {\n            uint256 allowed = allowance[sender][msg.sender][id];\n            if (allowed != type(uint256).max) allowance[sender][msg.sender][id] = allowed - amount;\n        }\n\n        balanceOf[sender][id] -= amount;\n\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, sender, receiver, id, amount);\n\n        return true;\n    }\n\n    function approve(\n        address spender,\n        uint256 id,\n        uint256 amount\n    ) public virtual returns (bool) {\n        allowance[msg.sender][spender][id] = amount;\n\n        emit Approval(msg.sender, spender, id, amount);\n\n        return true;\n    }\n\n    function setOperator(address operator, bool approved) public virtual returns (bool) {\n        isOperator[msg.sender][operator] = approved;\n\n        emit OperatorSet(msg.sender, operator, approved);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x0f632fb3; // ERC165 Interface ID for ERC6909\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[receiver][id] += amount;\n\n        emit Transfer(msg.sender, address(0), receiver, id, amount);\n    }\n\n    function _burn(\n        address sender,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[sender][id] -= amount;\n\n        emit Transfer(msg.sender, sender, address(0), id, amount);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/tokens/ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/tokens/WETH.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/Bytes32AddressLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/CREATE3.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        return getDeployed(salt, address(this));\n    }\n\n    function getDeployed(bytes32 salt, address creator) internal pure returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                creator,\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/FixedPointMathLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) return toString(uint256(value));\n\n        unchecked {\n            str = toString(uint256(-value));\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Note: This is only safe because we over-allocate memory\n                // and write the string from right to left in toString(uint256),\n                // and thus can be sure that sub(str, 1) is an unused memory location.\n\n                let length := mload(str) // Load the string length.\n                // Put the - character at the start of the string contents.\n                mstore(str, 45) // 45 is the ASCII code for the - character.\n                str := sub(str, 1) // Move back the string pointer by a byte.\n                mstore(str, add(length, 1)) // Update the string length.\n            }\n        }\n    }\n\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/MerkleProofLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/SSTORE2.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/SafeCastLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo240(uint256 x) internal pure returns (uint240 y) {\n        require(x < 1 << 240);\n\n        y = uint240(x);\n    }\n\n    function safeCastTo232(uint256 x) internal pure returns (uint232 y) {\n        require(x < 1 << 232);\n\n        y = uint232(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo216(uint256 x) internal pure returns (uint216 y) {\n        require(x < 1 << 216);\n\n        y = uint216(x);\n    }\n\n    function safeCastTo208(uint256 x) internal pure returns (uint208 y) {\n        require(x < 1 << 208);\n\n        y = uint208(x);\n    }\n\n    function safeCastTo200(uint256 x) internal pure returns (uint200 y) {\n        require(x < 1 << 200);\n\n        y = uint200(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo184(uint256 x) internal pure returns (uint184 y) {\n        require(x < 1 << 184);\n\n        y = uint184(x);\n    }\n\n    function safeCastTo176(uint256 x) internal pure returns (uint176 y) {\n        require(x < 1 << 176);\n\n        y = uint176(x);\n    }\n\n    function safeCastTo168(uint256 x) internal pure returns (uint168 y) {\n        require(x < 1 << 168);\n\n        y = uint168(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo152(uint256 x) internal pure returns (uint152 y) {\n        require(x < 1 << 152);\n\n        y = uint152(x);\n    }\n\n    function safeCastTo144(uint256 x) internal pure returns (uint144 y) {\n        require(x < 1 << 144);\n\n        y = uint144(x);\n    }\n\n    function safeCastTo136(uint256 x) internal pure returns (uint136 y) {\n        require(x < 1 << 136);\n\n        y = uint136(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo120(uint256 x) internal pure returns (uint120 y) {\n        require(x < 1 << 120);\n\n        y = uint120(x);\n    }\n\n    function safeCastTo112(uint256 x) internal pure returns (uint112 y) {\n        require(x < 1 << 112);\n\n        y = uint112(x);\n    }\n\n    function safeCastTo104(uint256 x) internal pure returns (uint104 y) {\n        require(x < 1 << 104);\n\n        y = uint104(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo88(uint256 x) internal pure returns (uint88 y) {\n        require(x < 1 << 88);\n\n        y = uint88(x);\n    }\n\n    function safeCastTo80(uint256 x) internal pure returns (uint80 y) {\n        require(x < 1 << 80);\n\n        y = uint80(x);\n    }\n\n    function safeCastTo72(uint256 x) internal pure returns (uint72 y) {\n        require(x < 1 << 72);\n\n        y = uint72(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo56(uint256 x) internal pure returns (uint56 y) {\n        require(x < 1 << 56);\n\n        y = uint56(x);\n    }\n\n    function safeCastTo48(uint256 x) internal pure returns (uint48 y) {\n        require(x < 1 << 48);\n\n        y = uint48(x);\n    }\n\n    function safeCastTo40(uint256 x) internal pure returns (uint40 y) {\n        require(x < 1 << 40);\n\n        y = uint40(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        require(x < 1 << 16);\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/src/utils/SignedWadMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Combined overflow check (`x == 0 || (x * y) / x == y`) and edge case check\n        // where x == -1 and y == type(int256).min, for y == -1 and x == min int256,\n        // the second overflow check will catch this.\n        // See: https://secure-contracts.com/learn_evm/arithmetic-checks.html#arithmetic-checks-for-int256-multiplication\n        // Combining into 1 expression saves gas as resulting bytecode will only have 1 `JUMPI`\n        // rather than 2.\n        if iszero(\n            and(\n                or(iszero(x), eq(sdiv(r, x), y)),\n                or(lt(x, not(0)), sgt(y, 0x8000000000000000000000000000000000000000000000000000000000000000))\n            )\n        ) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\n/// @dev Will not work with negative bases, only use when x is positive.\nfunction wadPow(int256 x, int256 y) pure returns (int256) {\n    // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n    return wadExp((wadLn(x) * y) / 1e18); // Using ln(x) means x must be greater than 0.\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n"}},"settings":{"remappings":["ds-test/=/Users/ae0h/cookbook-ecosystem/cookbook-compiler-testing/test-data/solmate/lib/ds-test/src/"],"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["*"]}},"evmVersion":"london","libraries":{}}}